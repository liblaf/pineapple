{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Melon","text":""},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>HOME</li> <li>API Reference</li> </ul>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>liblaf     * liblaf.melon         * liblaf.melon.cli         * liblaf.melon.io             * liblaf.melon.io.dispatcher                 * liblaf.melon.io.dispatcher.conversion                 * liblaf.melon.io.dispatcher.reader                 * liblaf.melon.io.dispatcher.writer             * liblaf.melon.io.melon                 * liblaf.melon.io.melon.dicom                     * liblaf.melon.io.melon.dicom.conversion             * liblaf.melon.io.pyvista                 * liblaf.melon.io.pyvista.image_data                     * liblaf.melon.io.pyvista.image_data.conversion                 * liblaf.melon.io.pyvista.point_set                     * liblaf.melon.io.pyvista.point_set.conversion                 * liblaf.melon.io.pyvista.poly_data                     * liblaf.melon.io.pyvista.poly_data.conversion                 * liblaf.melon.io.pyvista.unstructured_grid                     * liblaf.melon.io.pyvista.unstructured_grid.conversion             * liblaf.melon.io.trimesh                 * liblaf.melon.io.trimesh.trimesh                     * liblaf.melon.io.trimesh.trimesh.conversion             * liblaf.melon.io.wrap                 * liblaf.melon.io.wrap.landmarks                 * liblaf.melon.io.wrap.polygons         * liblaf.melon.ops             * liblaf.melon.ops.correspondence             * liblaf.melon.ops.pyvista             * liblaf.melon.ops.registration                 * liblaf.melon.ops.registration.rigid             * liblaf.melon.ops.selection             * liblaf.melon.ops.transfer             * liblaf.melon.ops.transformations         * liblaf.melon.plugin             * liblaf.melon.plugin.wrap                 * liblaf.melon.plugin.wrap.resources         * liblaf.melon.struct             * liblaf.melon.struct.dicom             * liblaf.melon.struct.dicom_dataset         * liblaf.melon.typed</li> </ul>"},{"location":"api/liblaf/melon/","title":"liblaf.melon","text":"<p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            </li> <li> <code>io</code>           \u2013            </li> <li> <code>ops</code>           \u2013            </li> <li> <code>plugin</code>           \u2013            </li> <li> <code>struct</code>           \u2013            </li> <li> <code>typed</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Acquisition</code>           \u2013            </li> <li> <code>AcquisitionMeta</code>           \u2013            </li> <li> <code>Attachments</code>           \u2013            </li> <li> <code>DICOM</code>           \u2013            </li> <li> <code>DICOMDataset</code>           \u2013            </li> <li> <code>DICOMDatasetMeta</code>           \u2013            </li> <li> <code>DICOMMeta</code>           \u2013            </li> <li> <code>NearestPointOnSurface</code>           \u2013            </li> <li> <code>NearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>NearestPointOnSurfaceResult</code>           \u2013            </li> <li> <code>NearestVertex</code>           \u2013            </li> <li> <code>NearestVertexPrepared</code>           \u2013            </li> <li> <code>NearestVertexResult</code>           \u2013            </li> <li> <code>RigidICP</code>           \u2013            </li> <li> <code>RigidRegistrationAlgorithm</code>           \u2013            </li> <li> <code>RigidRegistrationResult</code>           \u2013            </li> <li> <code>Subject</code>           \u2013            </li> <li> <code>SubjectMeta</code>           \u2013            </li> <li> <code>TransferAlgorithm</code>           \u2013            </li> <li> <code>TransferAlgorithmPrepared</code>           \u2013            </li> <li> <code>TransferAuto</code>           \u2013            </li> <li> <code>TransferAutoPrepared</code>           \u2013            </li> <li> <code>TransferNearestPointOnSurface</code>           \u2013            </li> <li> <code>TransferNearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>TransferNearestVertex</code>           \u2013            </li> <li> <code>TransferNearestVertexPrepared</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_image_data</code>             \u2013              </li> <li> <code>as_point_set</code>             \u2013              </li> <li> <code>as_poly_data</code>             \u2013              </li> <li> <code>as_trimesh</code>             \u2013              </li> <li> <code>as_unstructured_grid</code>             \u2013              </li> <li> <code>concat_transforms</code>             \u2013              </li> <li> <code>contour</code>             \u2013              </li> <li> <code>ensure_positive_volume</code>             \u2013              </li> <li> <code>extract_points</code>             \u2013              </li> <li> <code>format_date</code>             \u2013              </li> <li> <code>gaussian_smooth</code>             \u2013              </li> <li> <code>get_fill_value</code>             \u2013              </li> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_image_data</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>load_unstructured_grid</code>             \u2013              </li> <li> <code>nearest_point_on_surface</code>             \u2013              </li> <li> <code>nearest_vertex</code>             \u2013              </li> <li> <code>parse_date</code>             \u2013              </li> <li> <code>rigid_align</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> <li> <code>transfer_point_to_point</code>             \u2013              </li> <li> <code>transform</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>convert</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.convert","title":"convert  <code>module-attribute</code>","text":"<pre><code>convert = convert\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition","title":"Acquisition","text":"<pre><code>Acquisition(\n    path: StrPath, meta: AcquisitionMeta | None = None\n)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisition_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>meta</code>               (<code>AcquisitionMeta</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_age</code>               (<code>int</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>subject_id</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def __init__(self, path: StrPath, meta: AcquisitionMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.acquisition_date","title":"acquisition_date  <code>property</code>","text":"<pre><code>acquisition_date: date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: AcquisitionMeta\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.patient_age","title":"patient_age  <code>property</code>","text":"<pre><code>patient_age: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.subject_id","title":"subject_id  <code>property</code>","text":"<pre><code>subject_id: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path, meta=self.meta)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Acquisition.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"acquisition.json\", self.meta)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta","title":"AcquisitionMeta","text":"<p>               Bases: <code>DICOMMeta</code></p> <p>Attributes:</p> <ul> <li> <code>AcquisitionDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientAge</code>               (<code>int</code>)           \u2013            </li> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta.AcquisitionDate","title":"AcquisitionDate  <code>instance-attribute</code>","text":"<pre><code>AcquisitionDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta.PatientAge","title":"PatientAge  <code>instance-attribute</code>","text":"<pre><code>PatientAge: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.AcquisitionMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments","title":"Attachments","text":"<pre><code>Attachments(path: StrPath)\n</code></pre> <p>Methods:</p> <ul> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    self.path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Attachments.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM","title":"DICOM","text":"<pre><code>DICOM(path: StrPath)\n</code></pre> <p>Methods:</p> <ul> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisition_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>dirfile</code>               (<code>FileDataset</code>)           \u2013            </li> <li> <code>dirfile_path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>first_record</code>               (<code>FileDataset</code>)           \u2013            </li> <li> <code>image_data</code>               (<code>ImageData</code>)           \u2013            </li> <li> <code>meta</code>               (<code>DICOMMeta</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_age</code>               (<code>int</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>record_filepaths</code>               (<code>list[Path]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom/_dicom.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    path = Path(path)\n    if path.name == \"DIRFILE\":\n        path = path.parent\n    self.path = path\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.acquisition_date","title":"acquisition_date  <code>property</code>","text":"<pre><code>acquisition_date: date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.dirfile","title":"dirfile  <code>property</code>","text":"<pre><code>dirfile: FileDataset\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.dirfile_path","title":"dirfile_path  <code>property</code>","text":"<pre><code>dirfile_path: Path\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.first_record","title":"first_record  <code>property</code>","text":"<pre><code>first_record: FileDataset\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.image_data","title":"image_data  <code>property</code>","text":"<pre><code>image_data: ImageData\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: DICOMMeta\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = path\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.patient_age","title":"patient_age  <code>property</code>","text":"<pre><code>patient_age: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.record_filepaths","title":"record_filepaths  <code>property</code>","text":"<pre><code>record_filepaths: list[Path]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOM.save","title":"save","text":"<pre><code>save(path: StrPath) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_dicom.py</code> <pre><code>def save(self, path: StrPath) -&gt; None:\n    path = Path(path)\n    if path.name == \"DIRFILE\":\n        path = path.parent\n    path.mkdir(parents=True, exist_ok=True)\n    shutil.copy2(self.dirfile_path, path / \"DIRFILE\")\n    for record_filepath in self.record_filepaths:\n        shutil.copy2(record_filepath, path / record_filepath.name)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset","title":"DICOMDataset","text":"<pre><code>DICOMDataset(\n    path: StrPath, meta: DICOMDatasetMeta | None = None\n)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>add_subject</code>             \u2013              </li> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_acquisition</code>             \u2013              </li> <li> <code>get_subject</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisitions</code>               (<code>list[Acquisition]</code>)           \u2013            </li> <li> <code>meta</code>               (<code>DICOMDatasetMeta</code>)           \u2013            </li> <li> <code>n_acquisitions</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_subjects</code>               (<code>int</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>subjects</code>               (<code>list[Subject]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def __init__(self, path: StrPath, meta: DICOMDatasetMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.acquisitions","title":"acquisitions  <code>property</code>","text":"<pre><code>acquisitions: list[Acquisition]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: DICOMDatasetMeta\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.n_acquisitions","title":"n_acquisitions  <code>property</code>","text":"<pre><code>n_acquisitions: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.n_subjects","title":"n_subjects  <code>property</code>","text":"<pre><code>n_subjects: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.subjects","title":"subjects  <code>property</code>","text":"<pre><code>subjects: list[Subject]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.add_subject","title":"add_subject","text":"<pre><code>add_subject(meta: SubjectMeta) -&gt; Subject\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def add_subject(self, meta: SubjectMeta) -&gt; Subject:\n    subject = Subject(self.path / meta.PatientID, meta)\n    self.meta.subjects.append(subject.id)\n    self.save_meta()\n    return subject\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.get_acquisition","title":"get_acquisition","text":"<pre><code>get_acquisition(\n    subject_id: str, acq_date: DateLike\n) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def get_acquisition(\n    self, subject_id: str, acq_date: melon.struct.dicom.DateLike\n) -&gt; Acquisition:\n    subject: Subject = self.get_subject(subject_id)\n    return subject.get_acquisition(acq_date)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.get_subject","title":"get_subject","text":"<pre><code>get_subject(subject_id: str) -&gt; Subject\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def get_subject(self, subject_id: str) -&gt; Subject:\n    return Subject(self.path / subject_id)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDataset.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"dataset.json\", self.meta)\n    for subject in self.subjects:\n        subject.save_meta(path / subject.id)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDatasetMeta","title":"DICOMDatasetMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>subjects</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMDatasetMeta.subjects","title":"subjects  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subjects: list[str] = []\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta","title":"DICOMMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>AcquisitionDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientAge</code>               (<code>int</code>)           \u2013            </li> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta.AcquisitionDate","title":"AcquisitionDate  <code>instance-attribute</code>","text":"<pre><code>AcquisitionDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta.PatientAge","title":"PatientAge  <code>instance-attribute</code>","text":"<pre><code>PatientAge: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.DICOMMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface","title":"NearestPointOnSurface","text":"<p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def prepare(self, source: Any) -&gt; NearestPointOnSurfacePrepared:\n    source: tm.Trimesh = melon.as_trimesh(source)\n    return NearestPointOnSurfacePrepared(\n        distance_threshold=self.distance_threshold,\n        fallback_to_nearest_vertex=self.fallback_to_nearest_vertex,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n    )\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared","title":"NearestPointOnSurfacePrepared","text":"<p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: Trimesh\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.query","title":"query","text":"<pre><code>query(target: Any) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def query(self, target: Any) -&gt; NearestPointOnSurfaceResult:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    target: pv.PointSet = melon.as_point_set(target, point_normals=need_normals)\n    nearest: Float[np.ndarray, \"N 3\"]\n    distance: Float[np.ndarray, \" N\"]\n    triangle_id: Integer[np.ndarray, \" N\"]\n    nearest, distance, triangle_id = self.source.nearest.on_surface(target.points)\n    missing: Bool[np.ndarray, \" N\"] = (\n        distance &gt; self.distance_threshold * self.source.scale\n    )\n    if need_normals:\n        source_normals: Float[np.ndarray, \"N 3\"] = self.source.face_normals[\n            triangle_id\n        ]\n        target_normals: Float[np.ndarray, \"N 3\"] = target.point_data[\"Normals\"]\n        normal_similarity: Float[np.ndarray, \" N\"] = np.vecdot(\n            source_normals, target_normals\n        )\n        missing |= normal_similarity &lt; self.normal_threshold\n    distance[missing] = np.inf\n    nearest[missing] = np.nan\n    triangle_id[missing] = -1\n    result = NearestPointOnSurfaceResult(\n        distance=distance, missing=missing, nearest=nearest, triangle_id=triangle_id\n    )\n    if self.fallback_to_nearest_vertex:\n        result = self._fallback_to_nearest_vertex(target, result)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult","title":"NearestPointOnSurfaceResult","text":"<p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' N']</code>)           \u2013            <p>(N,) float</p> </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' N']</code>)           \u2013            <p>(N,) bool</p> </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'N 3']</code>)           \u2013            <p>(N, 3) float</p> </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            <p>(N,) int</p> </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' N']\n</code></pre> <p>(N,) float</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' N']\n</code></pre> <p>(N,) bool</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'N 3']\n</code></pre> <p>(N, 3) float</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.triangle_id","title":"triangle_id  <code>instance-attribute</code>","text":"<pre><code>triangle_id: Integer[ndarray, ' N']\n</code></pre> <p>(N,) int</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertex","title":"NearestVertex","text":"<p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertex.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertex.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertex.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertex.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertex.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestVertexPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def prepare(self, source: Any) -&gt; NearestVertexPrepared:\n    source: pv.PointSet = melon.as_point_set(\n        source, point_normals=self.normal_threshold &gt; -1.0\n    )\n    tree = KDTree(source.points)\n    return NearestVertexPrepared(\n        distance_threshold=self.distance_threshold,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n        tree=tree,\n    )\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared","title":"NearestVertexPrepared","text":"<p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: PointSet\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.tree","title":"tree  <code>instance-attribute</code>","text":"<pre><code>tree: KDTree\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexPrepared.query","title":"query","text":"<pre><code>query(target: Any) -&gt; NearestVertexResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def query(self, target: Any) -&gt; NearestVertexResult:\n    if self.normal_threshold &lt;= -1.0:\n        return self._nearest_vertex(target)\n    return self._nearest_vertex_with_normal_threshold(target)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexResult","title":"NearestVertexResult","text":"<p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' N']</code>)           \u2013            <p>(N,) float</p> </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' N']</code>)           \u2013            <p>(N,) bool</p> </li> <li> <code>nearest</code>               (<code>Float[ndarray, ' N 3']</code>)           \u2013            <p>(N, 3) float</p> </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            <p>(N,) int</p> </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' N']\n</code></pre> <p>(N,) float</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' N']\n</code></pre> <p>(N,) bool</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, ' N 3']\n</code></pre> <p>(N, 3) float</p>"},{"location":"api/liblaf/melon/#liblaf.melon.NearestVertexResult.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' N']\n</code></pre> <p>(N,) int</p>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP","title":"RigidICP","text":"<p>               Bases: <code>RigidRegistrationAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>corresp_algo</code>               (<code>NearestVertex</code>)           \u2013            </li> <li> <code>loss_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_iters</code>               (<code>int</code>)           \u2013            </li> <li> <code>reflection</code>               (<code>bool</code>)           \u2013            </li> <li> <code>scale</code>               (<code>bool</code>)           \u2013            </li> <li> <code>translation</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.corresp_algo","title":"corresp_algo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>corresp_algo: NearestVertex = field(factory=NearestVertex)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.loss_threshold","title":"loss_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loss_threshold: float = 1e-06\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.max_iters","title":"max_iters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_iters: int = 100\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scale: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.translation","title":"translation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>translation: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidICP.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_icp.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult:\n    corresp_algo_prepared: melon.NearestVertexPrepared = self.corresp_algo.prepare(\n        target\n    )\n    source: pv.PolyData = melon.as_poly_data(source)\n    target: pv.PolyData = melon.as_poly_data(target)\n    init_transform: Float[np.ndarray, \"4 4\"] = np.asarray(init_transform)\n    result = RigidRegistrationResult(\n        init_transform=init_transform,\n        loss=np.nan,\n        transformation=init_transform,\n        history=[np.eye(4)],\n    )\n    source_weights: Float[np.ndarray, \" N\"] | None = source.point_data.get(\n        \"Weights\"\n    )\n    target_weights: Float[np.ndarray, \" N\"] | None = target.point_data.get(\n        \"Weights\"\n    )\n    for it in range(self.max_iters):\n        transformed: pv.PolyData = source.transform(\n            result.transformation, inplace=False\n        )  # pyright: ignore[reportAssignmentType]\n        corresp: melon.NearestVertexResult = corresp_algo_prepared.query(\n            transformed\n        )\n        valid_mask: Bool[np.ndarray, \" N\"] = ~corresp.missing\n        matrix: Float[np.ndarray, \"4 4\"]\n        cost: float\n        source_points: Float[np.ndarray, \"N 3\"] = transformed.points[valid_mask]\n        target_points: Float[np.ndarray, \"N 3\"] = corresp.nearest[valid_mask]\n        weights: Float[np.ndarray, \" N\"] = np.ones((source_points.shape[0],))\n        if source_weights:\n            weights *= source_weights[valid_mask]\n        if target_weights:\n            weights *= target_weights[corresp.vertex_id[valid_mask]]\n        matrix, _, cost = tm.registration.procrustes(\n            source_points,\n            target_points,\n            weights=weights,\n            reflection=self.reflection,\n            translation=self.translation,\n            scale=self.scale,\n            return_cost=True,\n        )\n        last_loss: float = result.loss\n        result.loss = cost\n        result.transformation = matrix @ result.transformation\n        result.history.append(result.transformation)\n        # log loss metric\n        logger.debug(\"ICP (it: {}) &gt; loss: {}\", it, cost)\n        if last_loss - cost &lt; self.loss_threshold:\n            break\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationAlgorithm","title":"RigidRegistrationAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationAlgorithm.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_abc.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult: ...\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationResult","title":"RigidRegistrationResult","text":"<p>Attributes:</p> <ul> <li> <code>history</code>               (<code>list[Float[ndarray, '4 4']]</code>)           \u2013            </li> <li> <code>init_transform</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> <li> <code>loss</code>               (<code>float</code>)           \u2013            </li> <li> <code>transformation</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationResult.history","title":"history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history: list[Float[ndarray, '4 4']] = field(factory=list)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationResult.init_transform","title":"init_transform  <code>instance-attribute</code>","text":"<pre><code>init_transform: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationResult.loss","title":"loss  <code>instance-attribute</code>","text":"<pre><code>loss: float\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.RigidRegistrationResult.transformation","title":"transformation  <code>instance-attribute</code>","text":"<pre><code>transformation: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject","title":"Subject","text":"<pre><code>Subject(path: StrPath, meta: SubjectMeta | None = None)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>add_acquisition</code>             \u2013              </li> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_acquisition</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisitions</code>               (<code>list[Acquisition]</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>meta</code>               (<code>SubjectMeta</code>)           \u2013            </li> <li> <code>n_acquisitions</code>               (<code>int</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def __init__(self, path: StrPath, meta: SubjectMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.acquisitions","title":"acquisitions  <code>property</code>","text":"<pre><code>acquisitions: list[Acquisition]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: SubjectMeta\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.n_acquisitions","title":"n_acquisitions  <code>property</code>","text":"<pre><code>n_acquisitions: int\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(meta: AcquisitionMeta) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def add_acquisition(self, meta: AcquisitionMeta) -&gt; Acquisition:\n    acq_id: str = melon.struct.dicom.format_date(meta.AcquisitionDate)\n    acq = Acquisition(self.path / acq_id, meta)\n    self.meta.acquisitions.append(acq.acquisition_date)\n    self.save_meta()\n    return acq\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.get_acquisition","title":"get_acquisition","text":"<pre><code>get_acquisition(acq_date: DateLike) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def get_acquisition(self, acq_date: melon.struct.dicom.DateLike) -&gt; Acquisition:\n    acq_date: datetime.date = melon.struct.dicom.parse_date(acq_date)\n    return Acquisition(self.path / melon.struct.dicom.format_date(acq_date))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.Subject.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"subject.json\", self.meta)\n    for acq in self.acquisitions:\n        acq.save_meta(path / acq.id)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.SubjectMeta","title":"SubjectMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>acquisitions</code>               (<code>list[Date]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.SubjectMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.SubjectMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.SubjectMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.SubjectMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.SubjectMeta.acquisitions","title":"acquisitions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisitions: list[Date] = []\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAlgorithm","title":"TransferAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAlgorithm.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferAlgorithmPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_abc.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferAlgorithmPrepared: ...\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAlgorithmPrepared","title":"TransferAlgorithmPrepared","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAlgorithmPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Shaped[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_abc.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Shaped[np.ndarray, \"target_points ...\"]: ...\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAuto","title":"TransferAuto","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>categorial</code>               (<code>TransferAlgorithm</code>)           \u2013            </li> <li> <code>floating</code>               (<code>TransferAlgorithm</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAuto.categorial","title":"categorial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>categorial: TransferAlgorithm = field(\n    factory=TransferNearestVertex\n)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAuto.floating","title":"floating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>floating: TransferAlgorithm = field(\n    factory=TransferNearestPointOnSurface\n)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAuto.prepare","title":"prepare","text":"<pre><code>prepare(source: Any, target: Any) -&gt; TransferAutoPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_auto.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferAutoPrepared:\n    return TransferAutoPrepared(\n        floating=self.floating.prepare(source, target),\n        categorial=self.categorial.prepare(source, target),\n    )\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAutoPrepared","title":"TransferAutoPrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>categorial</code>               (<code>TransferAlgorithmPrepared</code>)           \u2013            </li> <li> <code>floating</code>               (<code>TransferAlgorithmPrepared</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAutoPrepared.categorial","title":"categorial  <code>instance-attribute</code>","text":"<pre><code>categorial: TransferAlgorithmPrepared\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAutoPrepared.floating","title":"floating  <code>instance-attribute</code>","text":"<pre><code>floating: TransferAlgorithmPrepared\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferAutoPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Shaped[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_auto.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Shaped[np.ndarray, \"target_points ...\"]:\n    data: Shaped[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    if np.isdtype(data.dtype, (\"bool\", \"integer\")):\n        return self.categorial.transfer(data, fill_value)\n    return self.floating.transfer(data, fill_value)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurface","title":"TransferNearestPointOnSurface","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = 0.8\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferNearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_point_on_surface.py</code> <pre><code>def prepare(\n    self, source: Any, target: Any\n) -&gt; TransferNearestPointOnSurfacePrepared:\n    source: tm.Trimesh = melon.as_trimesh(source)\n    corresp: melon.NearestPointOnSurfaceResult = melon.nearest_point_on_surface(\n        source,\n        target,\n        distance_threshold=self.distance_threshold,\n        normal_threshold=self.normal_threshold,\n    )\n    triangles: Integer[np.ndarray, \"target_points 3\"] = source.faces[\n        corresp.triangle_id\n    ]\n    barycentric: Float[np.ndarray, \"target_points 3\"] = (\n        tm.triangles.points_to_barycentric(\n            source.vertices[triangles], corresp.nearest\n        )\n    )\n    barycentric[corresp.missing] = np.nan\n    triangles[corresp.missing] = -1\n    return TransferNearestPointOnSurfacePrepared(\n        barycentric=barycentric, missing=corresp.missing, triangles=triangles\n    )\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurfacePrepared","title":"TransferNearestPointOnSurfacePrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>barycentric</code>               (<code>Float[ndarray, 'target_points 3']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' target_points']</code>)           \u2013            </li> <li> <code>triangles</code>               (<code>Integer[ndarray, 'target_points 3']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurfacePrepared.barycentric","title":"barycentric  <code>instance-attribute</code>","text":"<pre><code>barycentric: Float[ndarray, 'target_points 3']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurfacePrepared.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurfacePrepared.triangles","title":"triangles  <code>instance-attribute</code>","text":"<pre><code>triangles: Integer[ndarray, 'target_points 3']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestPointOnSurfacePrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Float[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_point_on_surface.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Float[np.ndarray, \"target_points ...\"]:\n    data: Float[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    result: Float[np.ndarray, \"target_points ...\"] = np.einsum(\n        \"ij,ij...-&gt;i...\", self.barycentric, data[self.triangles], dtype=data.dtype\n    )\n    result[self.missing] = fill_value\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertex","title":"TransferNearestVertex","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_upper_bound</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertex.distance_upper_bound","title":"distance_upper_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_upper_bound: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertex.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertex.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = 0.8\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertex.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertex.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferNearestVertexPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_vertex.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferNearestVertexPrepared:\n    corresp: melon.NearestVertexResult = melon.nearest_vertex(\n        source,\n        target,\n        distance_threshold=self.distance_upper_bound,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n    )\n    return TransferNearestVertexPrepared(\n        missing=corresp.missing, vertex_id=corresp.vertex_id\n    )\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertexPrepared","title":"TransferNearestVertexPrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>missing</code>               (<code>Bool[ndarray, ' target_points']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' target_points']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertexPrepared.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertexPrepared.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.TransferNearestVertexPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_vertex.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Any:\n    data: Num[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    result: Shaped[np.ndarray, \"target_points ...\"] = data[self.vertex_id].copy()\n    result[self.missing] = fill_value\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.as_image_data","title":"as_image_data","text":"<pre><code>as_image_data(data: Any) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/conversion/_as.py</code> <pre><code>def as_image_data(data: Any) -&gt; pv.ImageData:\n    return conversion_dispatcher.convert(data, pv.ImageData)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.as_point_set","title":"as_point_set","text":"<pre><code>as_point_set(\n    data: Any, *, point_normals: bool = False\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_as.py</code> <pre><code>def as_point_set(data: Any, *, point_normals: bool = False) -&gt; pv.PointSet:\n    if point_normals:\n        return _as_point_set_with_normals(data)\n    return _as_point_set(data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.as_poly_data","title":"as_poly_data","text":"<pre><code>as_poly_data(obj: Any) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/conversion/_as.py</code> <pre><code>def as_poly_data(obj: Any) -&gt; pv.PolyData:\n    return conversion_dispatcher.convert(obj, pv.PolyData)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.as_trimesh","title":"as_trimesh","text":"<pre><code>as_trimesh(data: Any) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/trimesh/conversion/_as.py</code> <pre><code>def as_trimesh(data: Any) -&gt; tm.Trimesh:\n    return conversion_dispatcher.convert(data, tm.Trimesh)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.as_unstructured_grid","title":"as_unstructured_grid","text":"<pre><code>as_unstructured_grid(obj: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_as.py</code> <pre><code>def as_unstructured_grid(obj: Any) -&gt; pv.UnstructuredGrid:\n    return conversion_dispatcher.convert(obj, pv.UnstructuredGrid)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.concat_transforms","title":"concat_transforms","text":"<pre><code>concat_transforms(\n    *transform: Float[ArrayLike, \"4 4\"] | None,\n) -&gt; Float[ndarray, \"4 4\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transformations/_concat.py</code> <pre><code>def concat_transforms(\n    *transform: Float[ArrayLike, \"4 4\"] | None,\n) -&gt; Float[np.ndarray, \"4 4\"]:\n    result: Float[np.ndarray, \"4 4\"] = np.eye(4)\n    for t in transform:\n        if t is None:\n            continue\n        result = result @ np.asarray(t)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.contour","title":"contour","text":"<pre><code>contour(\n    data: Any,\n    isosurfaces: int | Sequence[float] | None = None,\n    scalars: str | Float[ArrayLike, ...] | None = None,\n    *,\n    compute_normals: bool = False,\n    compute_gradients: bool = False,\n    compute_scalars: bool = True,\n    rng: Sequence[float] | None = None,\n    preference: Literal[\"point\", \"cell\"] = \"point\",\n    method: Literal[\n        \"contour\", \"marching_cubes\", \"flying_edges\"\n    ] = \"contour\",\n    progress_bar: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_contour.py</code> <pre><code>def contour(\n    data: Any,\n    isosurfaces: int | Sequence[float] | None = None,\n    scalars: str | Float[ArrayLike, \"...\"] | None = None,\n    *,\n    compute_normals: bool = False,\n    compute_gradients: bool = False,\n    compute_scalars: bool = True,\n    rng: Sequence[float] | None = None,\n    preference: Literal[\"point\", \"cell\"] = \"point\",\n    method: Literal[\"contour\", \"marching_cubes\", \"flying_edges\"] = \"contour\",\n    progress_bar: bool = False,\n) -&gt; pv.PolyData:\n    data: pv.ImageData = melon.as_image_data(data)\n    result: pv.PolyData = data.contour(  # pyright: ignore[reportAssignmentType]\n        isosurfaces=isosurfaces,  # pyright: ignore[reportArgumentType]\n        scalars=scalars,\n        compute_normals=compute_normals,\n        compute_gradients=compute_gradients,\n        compute_scalars=compute_scalars,\n        rng=rng,\n        preference=preference,\n        method=method,\n        progress_bar=progress_bar,\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.ensure_positive_volume","title":"ensure_positive_volume","text":"<pre><code>ensure_positive_volume(mesh: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_tetra.py</code> <pre><code>def ensure_positive_volume(mesh: Any) -&gt; pv.UnstructuredGrid:\n    mesh: pv.UnstructuredGrid = melon.as_unstructured_grid(mesh)\n    mesh = mesh.compute_cell_sizes(\n        length=False, area=False, volume=True, vertex_count=False\n    )  # pyright: ignore[reportAssignmentType]\n    return flip(mesh, mask=mesh.cell_data[\"Volume\"] &lt; 0)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.extract_points","title":"extract_points","text":"<pre><code>extract_points(\n    data: Any,\n    ind: Bool[ArrayLike, \" N\"] | Integer[ArrayLike, \" N\"],\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_extract_points.py</code> <pre><code>def extract_points(\n    data: Any, ind: Bool[ArrayLike, \" N\"] | Integer[ArrayLike, \" N\"]\n) -&gt; pv.PointSet:\n    data: pv.PointSet = melon.as_point_set(data)\n    unstructured: pv.UnstructuredGrid = data.extract_points(ind)  # pyright: ignore[reportAssignmentType]\n    return melon.as_point_set(unstructured)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.format_date","title":"format_date","text":"<pre><code>format_date(date: date) -&gt; str\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>def format_date(date: datetime.date) -&gt; str:\n    return date.strftime(\"%Y%m%d\")\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.gaussian_smooth","title":"gaussian_smooth","text":"<pre><code>gaussian_smooth(\n    data: Any,\n    radius_factor: float | Sequence[float] = 1.5,\n    std_dev: float | Sequence[float] = 2.0,\n    scalars: str | None = None,\n    *,\n    progress_bar: bool = False,\n) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_gaussian_smooth.py</code> <pre><code>def gaussian_smooth(\n    data: Any,\n    radius_factor: float | Sequence[float] = 1.5,\n    std_dev: float | Sequence[float] = 2.0,\n    scalars: str | None = None,\n    *,\n    progress_bar: bool = False,\n) -&gt; pv.ImageData:\n    data: pv.ImageData = melon.as_image_data(data)\n    result: pv.ImageData = data.gaussian_smooth(  # pyright: ignore[reportAssignmentType]\n        radius_factor=radius_factor,  # pyright: ignore[reportArgumentType]\n        std_dev=std_dev,  # pyright: ignore[reportArgumentType]\n        scalars=scalars,\n        progress_bar=progress_bar,\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.get_fill_value","title":"get_fill_value","text":"<pre><code>get_fill_value(\n    dtype: DTypeLike, fill_value: ScalarLike | None = None\n) -&gt; ScalarLike\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_utils.py</code> <pre><code>def get_fill_value(\n    dtype: DTypeLike, fill_value: ScalarLike | None = None\n) -&gt; ScalarLike:\n    if fill_value is not None:\n        return fill_value\n    return np.zeros((), dtype=dtype).item()\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/_load.py</code> <pre><code>def load(path: StrPath) -&gt; Any:\n    return reader_dispatcher.load(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(path: StrPath) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def load_dicom(path: StrPath) -&gt; melon.DICOM:\n    return melon.DICOM(path)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load_image_data","title":"load_image_data","text":"<pre><code>load_image_data(path: StrPath) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/_reader.py</code> <pre><code>def load_image_data(path: StrPath) -&gt; pv.ImageData:\n    path = Path(path)\n    if path.is_file() and path.name == \"DIRFILE\":\n        path = path.parent\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return pv.read(path, force_ext=\".dcm\")  # pyright: ignore[reportReturnType]\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(path: StrPath) -&gt; Float[ndarray, 'N 3']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: StrPath) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    data: list[dict[str, float]] = grapes.deserialize(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(path: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_reader.py</code> <pre><code>def load_poly_data(path: StrPath) -&gt; pv.PolyData:\n    path = Path(path)\n    if path.suffix == \".obj\":\n        return load_obj(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: StrPath) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: StrPath) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.deserialize(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.load_unstructured_grid","title":"load_unstructured_grid","text":"<pre><code>load_unstructured_grid(path: StrPath) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_reader.py</code> <pre><code>def load_unstructured_grid(path: StrPath) -&gt; pv.UnstructuredGrid:\n    path = Path(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.nearest_point_on_surface","title":"nearest_point_on_surface","text":"<pre><code>nearest_point_on_surface(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    fallback_to_nearest_vertex: bool = False,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def nearest_point_on_surface(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    fallback_to_nearest_vertex: bool = False,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestPointOnSurfaceResult:\n    algorithm = NearestPointOnSurface(\n        distance_threshold=distance_threshold,\n        fallback_to_nearest_vertex=fallback_to_nearest_vertex,\n        max_k=max_k,\n        normal_threshold=normal_threshold,\n        workers=workers,\n    )\n    prepared: NearestPointOnSurfacePrepared = algorithm.prepare(source)\n    return prepared.query(target)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.nearest_vertex","title":"nearest_vertex","text":"<pre><code>nearest_vertex(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestVertexResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def nearest_vertex(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestVertexResult:\n    algorithm = NearestVertex(\n        distance_threshold=distance_threshold,\n        max_k=max_k,\n        normal_threshold=normal_threshold,\n        workers=workers,\n    )\n    prepared: NearestVertexPrepared = algorithm.prepare(source)\n    return prepared.query(target)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.parse_date","title":"parse_date","text":"<pre><code>parse_date(date: DateLike) -&gt; date\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>def parse_date(date: DateLike) -&gt; datetime.date:\n    match date:\n        case str():\n            return datetime.datetime.strptime(date, \"%Y%m%d\").date()  # noqa: DTZ007\n        case datetime.datetime():\n            return date.date()\n        case datetime.date():\n            return date\n        case _:\n            msg: str = f\"Invalid date: `{date}`\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.rigid_align","title":"rigid_align","text":"<pre><code>rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_main.py</code> <pre><code>def rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult:\n    algorithm = algorithm or RigidICP()\n    init_transform = np.eye(4) if init_transform is None else init_transform\n    result: RigidRegistrationResult = algorithm.register(\n        source, target, init_transform=init_transform\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/_save.py</code> <pre><code>def save(path: StrPath, obj: Any) -&gt; None:\n    writer_dispatcher.save(path, obj)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: StrPath, points: Float[ArrayLike, \"N 3\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(path: StrPath, points: Float[ArrayLike, \"N 3\"]) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [{\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points]\n    grapes.serialize(path, data)\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: StrPath, polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(path: StrPath, polygons: Integer[ArrayLike, \" N\"]) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.serialize(path, polygons.tolist())\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.transfer_point_to_point","title":"transfer_point_to_point","text":"<pre><code>transfer_point_to_point(\n    source: Any,\n    target: Any,\n    data: Iterable[str],\n    *,\n    algo: TransferAlgorithm | None = None,\n    fill_value: ScalarLike\n    | Mapping[str, ScalarLike | None]\n    | None = None,\n) -&gt; Attrs\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_transfer.py</code> <pre><code>def transfer_point_to_point(\n    source: Any,\n    target: Any,\n    data: Iterable[str],\n    *,\n    algo: TransferAlgorithm | None = None,\n    fill_value: ScalarLike | Mapping[str, ScalarLike | None] | None = None,\n) -&gt; Attrs:\n    if algo is None:\n        algo = TransferAuto()\n    if not isinstance(fill_value, Mapping):\n        fill_value = {key: fill_value for key in data}\n    prepared: TransferAlgorithmPrepared = algo.prepare(source, target)\n    source: pv.PointSet = melon.as_point_set(source)\n    result: Attrs = {}\n    for key in data:\n        attr: np.ndarray = source.point_data[key]\n        fill: ScalarLike = get_fill_value(attr.dtype, fill_value.get(key))\n        result[key] = prepared.transfer(attr, fill_value=fill)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/#liblaf.melon.transform","title":"transform","text":"<pre><code>transform(\n    data: Any,\n    trans: Float[ArrayLike, \"4 4\"] | None,\n    *,\n    transform_all_input_vectors: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_transform.py</code> <pre><code>def transform(\n    data: Any,\n    trans: Float[ArrayLike, \"4 4\"] | None,\n    *,\n    transform_all_input_vectors: bool = False,\n) -&gt; pv.PolyData:\n    if trans is None:\n        return data\n    trans: Float[np.ndarray, \"4 4\"] = np.asarray(trans)\n    data: pv.PolyData = melon.as_poly_data(data)\n    data = data.transform(\n        trans, transform_all_input_vectors=transform_all_input_vectors, inplace=False\n    )  # pyright: ignore[reportAssignmentType]\n    return data\n</code></pre>"},{"location":"api/liblaf/melon/cli/","title":"liblaf.melon.cli","text":""},{"location":"api/liblaf/melon/io/","title":"liblaf.melon.io","text":"<p>Modules:</p> <ul> <li> <code>dispatcher</code>           \u2013            </li> <li> <code>melon</code>           \u2013            </li> <li> <code>pyvista</code>           \u2013            </li> <li> <code>trimesh</code>           \u2013            </li> <li> <code>wrap</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>AbstractConverter</code>           \u2013            </li> <li> <code>AbstractReader</code>           \u2013            </li> <li> <code>AbstractWriter</code>           \u2013            </li> <li> <code>ConversionDispatcher</code>           \u2013            </li> <li> <code>ReaderDispatcher</code>           \u2013            </li> <li> <code>UnsupportedConversionError</code>           \u2013            </li> <li> <code>WriterDispatcher</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_image_data</code>             \u2013              </li> <li> <code>as_point_set</code>             \u2013              </li> <li> <code>as_poly_data</code>             \u2013              </li> <li> <code>as_trimesh</code>             \u2013              </li> <li> <code>as_unstructured_grid</code>             \u2013              </li> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_image_data</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>load_unstructured_grid</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> <li> <code>warning_unsupported_association</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>SUFFIXES</code>               (<code>set[str]</code>)           \u2013            </li> <li> <code>conversion_dispatcher</code>           \u2013            </li> <li> <code>convert</code>           \u2013            </li> <li> <code>reader_dispatcher</code>           \u2013            </li> <li> <code>register_converter</code>           \u2013            </li> <li> <code>register_reader</code>           \u2013            </li> <li> <code>register_writer</code>           \u2013            </li> <li> <code>writer_dispatcher</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.SUFFIXES","title":"SUFFIXES  <code>module-attribute</code>","text":"<pre><code>SUFFIXES: set[str] = {'.obj', '.ply', '.vtp', '.vtu'}\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.conversion_dispatcher","title":"conversion_dispatcher  <code>module-attribute</code>","text":"<pre><code>conversion_dispatcher = ConversionDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.convert","title":"convert  <code>module-attribute</code>","text":"<pre><code>convert = convert\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.reader_dispatcher","title":"reader_dispatcher  <code>module-attribute</code>","text":"<pre><code>reader_dispatcher = ReaderDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.register_converter","title":"register_converter  <code>module-attribute</code>","text":"<pre><code>register_converter = register\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.register_reader","title":"register_reader  <code>module-attribute</code>","text":"<pre><code>register_reader = register\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.register_writer","title":"register_writer  <code>module-attribute</code>","text":"<pre><code>register_writer = register\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.writer_dispatcher","title":"writer_dispatcher  <code>module-attribute</code>","text":"<pre><code>writer_dispatcher = WriterDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter","title":"AbstractConverter","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>               (<code>type</code>)           \u2013            </li> <li> <code>type_to</code>               (<code>type</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter.type_from","title":"type_from  <code>instance-attribute</code>","text":"<pre><code>type_from: type\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter.type_to","title":"type_to  <code>instance-attribute</code>","text":"<pre><code>type_to: type\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter.convert","title":"convert  <code>abstractmethod</code>","text":"<pre><code>convert(obj: Any) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>@abc.abstractmethod\ndef convert(self, obj: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractConverter.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractReader","title":"AbstractReader","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractReader.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractReader.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>@abc.abstractmethod\ndef load(self, path: StrPath) -&gt; Any: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractWriter","title":"AbstractWriter","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractWriter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.AbstractWriter.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>@abc.abstractmethod\ndef save(self, path: StrPath, obj: Any) -&gt; None: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ConversionDispatcher","title":"ConversionDispatcher","text":"<pre><code>ConversionDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>converters</code>               (<code>list[AbstractConverter]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.converters = []\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ConversionDispatcher.converters","title":"converters  <code>instance-attribute</code>","text":"<pre><code>converters: list[AbstractConverter] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ConversionDispatcher.convert","title":"convert","text":"<pre><code>convert(obj: Any, type_to: type[_T]) -&gt; _T\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def convert(self, obj: Any, type_to: type[_T]) -&gt; _T:\n    if isinstance(obj, type_to):\n        return obj\n    for converter in self.converters:\n        if converter.match_from(obj) and converter.match_to(type_to):\n            return converter.convert(obj)\n    raise UnsupportedConversionError(obj, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ConversionDispatcher.register","title":"register","text":"<pre><code>register(converter: AbstractConverter) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def register(self, converter: AbstractConverter) -&gt; None:\n    bisect.insort(self.converters, converter, key=lambda c: c.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ReaderDispatcher","title":"ReaderDispatcher","text":"<pre><code>ReaderDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>readers</code>               (<code>list[AbstractReader]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.readers = []\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ReaderDispatcher.readers","title":"readers  <code>instance-attribute</code>","text":"<pre><code>readers: list[AbstractReader] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ReaderDispatcher.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def load(self, path: StrPath) -&gt; Any:\n    for reader in self.readers:\n        if reader.match_path(path):\n            return reader.load(path)\n    raise UnsupportedReaderError(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.ReaderDispatcher.register","title":"register","text":"<pre><code>register(reader: AbstractReader) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def register(self, reader: AbstractReader) -&gt; None:\n    bisect.insort(self.readers, reader, key=lambda r: r.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.UnsupportedConversionError","title":"UnsupportedConversionError","text":"<pre><code>UnsupportedConversionError(obj: Any, type_to: type)\n</code></pre> <p>               Bases: <code>TypeError</code></p> <p>Attributes:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            </li> <li> <code>type_to</code>               (<code>type</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_utils.py</code> <pre><code>def __init__(self, obj: Any, type_to: type) -&gt; None:\n    self.obj = obj\n    self.type_to = type_to\n    super().__init__(f\"Cannot convert `{obj}` to `{type_to}`.\")\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.UnsupportedConversionError.obj","title":"obj  <code>instance-attribute</code>","text":"<pre><code>obj: Any = obj\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.UnsupportedConversionError.type_to","title":"type_to  <code>instance-attribute</code>","text":"<pre><code>type_to: type = type_to\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.WriterDispatcher","title":"WriterDispatcher","text":"<pre><code>WriterDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>writers</code>               (<code>list[AbstractWriter]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.writers = []\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.WriterDispatcher.writers","title":"writers  <code>instance-attribute</code>","text":"<pre><code>writers: list[AbstractWriter] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.WriterDispatcher.register","title":"register","text":"<pre><code>register(writer: AbstractWriter) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def register(self, writer: AbstractWriter) -&gt; None:\n    bisect.insort(self.writers, writer, key=lambda r: r.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.WriterDispatcher.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    for writer in self.writers:\n        if writer.match_path(path):\n            return writer.save(path, obj)\n    raise UnsupportedWriterError(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.as_image_data","title":"as_image_data","text":"<pre><code>as_image_data(data: Any) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/conversion/_as.py</code> <pre><code>def as_image_data(data: Any) -&gt; pv.ImageData:\n    return conversion_dispatcher.convert(data, pv.ImageData)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.as_point_set","title":"as_point_set","text":"<pre><code>as_point_set(\n    data: Any, *, point_normals: bool = False\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_as.py</code> <pre><code>def as_point_set(data: Any, *, point_normals: bool = False) -&gt; pv.PointSet:\n    if point_normals:\n        return _as_point_set_with_normals(data)\n    return _as_point_set(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.as_poly_data","title":"as_poly_data","text":"<pre><code>as_poly_data(obj: Any) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/conversion/_as.py</code> <pre><code>def as_poly_data(obj: Any) -&gt; pv.PolyData:\n    return conversion_dispatcher.convert(obj, pv.PolyData)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.as_trimesh","title":"as_trimesh","text":"<pre><code>as_trimesh(data: Any) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/trimesh/conversion/_as.py</code> <pre><code>def as_trimesh(data: Any) -&gt; tm.Trimesh:\n    return conversion_dispatcher.convert(data, tm.Trimesh)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.as_unstructured_grid","title":"as_unstructured_grid","text":"<pre><code>as_unstructured_grid(obj: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_as.py</code> <pre><code>def as_unstructured_grid(obj: Any) -&gt; pv.UnstructuredGrid:\n    return conversion_dispatcher.convert(obj, pv.UnstructuredGrid)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/_load.py</code> <pre><code>def load(path: StrPath) -&gt; Any:\n    return reader_dispatcher.load(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(path: StrPath) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def load_dicom(path: StrPath) -&gt; melon.DICOM:\n    return melon.DICOM(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load_image_data","title":"load_image_data","text":"<pre><code>load_image_data(path: StrPath) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/_reader.py</code> <pre><code>def load_image_data(path: StrPath) -&gt; pv.ImageData:\n    path = Path(path)\n    if path.is_file() and path.name == \"DIRFILE\":\n        path = path.parent\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return pv.read(path, force_ext=\".dcm\")  # pyright: ignore[reportReturnType]\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(path: StrPath) -&gt; Float[ndarray, 'N 3']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: StrPath) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    data: list[dict[str, float]] = grapes.deserialize(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(path: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_reader.py</code> <pre><code>def load_poly_data(path: StrPath) -&gt; pv.PolyData:\n    path = Path(path)\n    if path.suffix == \".obj\":\n        return load_obj(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: StrPath) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: StrPath) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.deserialize(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.load_unstructured_grid","title":"load_unstructured_grid","text":"<pre><code>load_unstructured_grid(path: StrPath) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_reader.py</code> <pre><code>def load_unstructured_grid(path: StrPath) -&gt; pv.UnstructuredGrid:\n    path = Path(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/_save.py</code> <pre><code>def save(path: StrPath, obj: Any) -&gt; None:\n    writer_dispatcher.save(path, obj)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: StrPath, points: Float[ArrayLike, \"N 3\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(path: StrPath, points: Float[ArrayLike, \"N 3\"]) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [{\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points]\n    grapes.serialize(path, data)\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: StrPath, polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(path: StrPath, polygons: Integer[ArrayLike, \" N\"]) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.serialize(path, polygons.tolist())\n</code></pre>"},{"location":"api/liblaf/melon/io/#liblaf.melon.io.warning_unsupported_association","title":"warning_unsupported_association","text":"<pre><code>warning_unsupported_association(\n    to: type,\n    association: FieldAssociation,\n    attr: Any | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_utils.py</code> <pre><code>def warning_unsupported_association(\n    to: type, association: pv.FieldAssociation, attr: Any | None = None\n) -&gt; None:\n    if attr is None:\n        return\n    logger.warning(\"{:r} does not support {:r} data\", to, association)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/","title":"liblaf.melon.io.dispatcher","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> <li> <code>reader</code>           \u2013            </li> <li> <code>writer</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>AbstractConverter</code>           \u2013            </li> <li> <code>AbstractReader</code>           \u2013            </li> <li> <code>AbstractWriter</code>           \u2013            </li> <li> <code>ConversionDispatcher</code>           \u2013            </li> <li> <code>ReaderDispatcher</code>           \u2013            </li> <li> <code>UnsupportedConversionError</code>           \u2013            </li> <li> <code>WriterDispatcher</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>warning_unsupported_association</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>conversion_dispatcher</code>           \u2013            </li> <li> <code>convert</code>           \u2013            </li> <li> <code>load</code>           \u2013            </li> <li> <code>reader_dispatcher</code>           \u2013            </li> <li> <code>register_converter</code>           \u2013            </li> <li> <code>register_reader</code>           \u2013            </li> <li> <code>register_writer</code>           \u2013            </li> <li> <code>save</code>           \u2013            </li> <li> <code>writer_dispatcher</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.conversion_dispatcher","title":"conversion_dispatcher  <code>module-attribute</code>","text":"<pre><code>conversion_dispatcher = ConversionDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.convert","title":"convert  <code>module-attribute</code>","text":"<pre><code>convert = convert\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.load","title":"load  <code>module-attribute</code>","text":"<pre><code>load = load\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.reader_dispatcher","title":"reader_dispatcher  <code>module-attribute</code>","text":"<pre><code>reader_dispatcher = ReaderDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.register_converter","title":"register_converter  <code>module-attribute</code>","text":"<pre><code>register_converter = register\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.register_reader","title":"register_reader  <code>module-attribute</code>","text":"<pre><code>register_reader = register\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.register_writer","title":"register_writer  <code>module-attribute</code>","text":"<pre><code>register_writer = register\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.save","title":"save  <code>module-attribute</code>","text":"<pre><code>save = save\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.writer_dispatcher","title":"writer_dispatcher  <code>module-attribute</code>","text":"<pre><code>writer_dispatcher = WriterDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter","title":"AbstractConverter","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>               (<code>type</code>)           \u2013            </li> <li> <code>type_to</code>               (<code>type</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter.type_from","title":"type_from  <code>instance-attribute</code>","text":"<pre><code>type_from: type\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter.type_to","title":"type_to  <code>instance-attribute</code>","text":"<pre><code>type_to: type\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter.convert","title":"convert  <code>abstractmethod</code>","text":"<pre><code>convert(obj: Any) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>@abc.abstractmethod\ndef convert(self, obj: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractConverter.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractReader","title":"AbstractReader","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractReader.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractReader.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>@abc.abstractmethod\ndef load(self, path: StrPath) -&gt; Any: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractWriter","title":"AbstractWriter","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractWriter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.AbstractWriter.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>@abc.abstractmethod\ndef save(self, path: StrPath, obj: Any) -&gt; None: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ConversionDispatcher","title":"ConversionDispatcher","text":"<pre><code>ConversionDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>converters</code>               (<code>list[AbstractConverter]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.converters = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ConversionDispatcher.converters","title":"converters  <code>instance-attribute</code>","text":"<pre><code>converters: list[AbstractConverter] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ConversionDispatcher.convert","title":"convert","text":"<pre><code>convert(obj: Any, type_to: type[_T]) -&gt; _T\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def convert(self, obj: Any, type_to: type[_T]) -&gt; _T:\n    if isinstance(obj, type_to):\n        return obj\n    for converter in self.converters:\n        if converter.match_from(obj) and converter.match_to(type_to):\n            return converter.convert(obj)\n    raise UnsupportedConversionError(obj, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ConversionDispatcher.register","title":"register","text":"<pre><code>register(converter: AbstractConverter) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def register(self, converter: AbstractConverter) -&gt; None:\n    bisect.insort(self.converters, converter, key=lambda c: c.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ReaderDispatcher","title":"ReaderDispatcher","text":"<pre><code>ReaderDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>readers</code>               (<code>list[AbstractReader]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.readers = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ReaderDispatcher.readers","title":"readers  <code>instance-attribute</code>","text":"<pre><code>readers: list[AbstractReader] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ReaderDispatcher.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def load(self, path: StrPath) -&gt; Any:\n    for reader in self.readers:\n        if reader.match_path(path):\n            return reader.load(path)\n    raise UnsupportedReaderError(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.ReaderDispatcher.register","title":"register","text":"<pre><code>register(reader: AbstractReader) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def register(self, reader: AbstractReader) -&gt; None:\n    bisect.insort(self.readers, reader, key=lambda r: r.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.UnsupportedConversionError","title":"UnsupportedConversionError","text":"<pre><code>UnsupportedConversionError(obj: Any, type_to: type)\n</code></pre> <p>               Bases: <code>TypeError</code></p> <p>Attributes:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            </li> <li> <code>type_to</code>               (<code>type</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_utils.py</code> <pre><code>def __init__(self, obj: Any, type_to: type) -&gt; None:\n    self.obj = obj\n    self.type_to = type_to\n    super().__init__(f\"Cannot convert `{obj}` to `{type_to}`.\")\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.UnsupportedConversionError.obj","title":"obj  <code>instance-attribute</code>","text":"<pre><code>obj: Any = obj\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.UnsupportedConversionError.type_to","title":"type_to  <code>instance-attribute</code>","text":"<pre><code>type_to: type = type_to\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.WriterDispatcher","title":"WriterDispatcher","text":"<pre><code>WriterDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>writers</code>               (<code>list[AbstractWriter]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.writers = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.WriterDispatcher.writers","title":"writers  <code>instance-attribute</code>","text":"<pre><code>writers: list[AbstractWriter] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.WriterDispatcher.register","title":"register","text":"<pre><code>register(writer: AbstractWriter) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def register(self, writer: AbstractWriter) -&gt; None:\n    bisect.insort(self.writers, writer, key=lambda r: r.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.WriterDispatcher.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    for writer in self.writers:\n        if writer.match_path(path):\n            return writer.save(path, obj)\n    raise UnsupportedWriterError(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/#liblaf.melon.io.dispatcher.warning_unsupported_association","title":"warning_unsupported_association","text":"<pre><code>warning_unsupported_association(\n    to: type,\n    association: FieldAssociation,\n    attr: Any | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_utils.py</code> <pre><code>def warning_unsupported_association(\n    to: type, association: pv.FieldAssociation, attr: Any | None = None\n) -&gt; None:\n    if attr is None:\n        return\n    logger.warning(\"{:r} does not support {:r} data\", to, association)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/","title":"liblaf.melon.io.dispatcher.conversion","text":"<p>Classes:</p> <ul> <li> <code>AbstractConverter</code>           \u2013            </li> <li> <code>ConversionDispatcher</code>           \u2013            </li> <li> <code>UnsupportedConversionError</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>warning_unsupported_association</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>conversion_dispatcher</code>           \u2013            </li> <li> <code>convert</code>           \u2013            </li> <li> <code>register_converter</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.conversion_dispatcher","title":"conversion_dispatcher  <code>module-attribute</code>","text":"<pre><code>conversion_dispatcher = ConversionDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.convert","title":"convert  <code>module-attribute</code>","text":"<pre><code>convert = convert\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.register_converter","title":"register_converter  <code>module-attribute</code>","text":"<pre><code>register_converter = register\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter","title":"AbstractConverter","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>               (<code>type</code>)           \u2013            </li> <li> <code>type_to</code>               (<code>type</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter.type_from","title":"type_from  <code>instance-attribute</code>","text":"<pre><code>type_from: type\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter.type_to","title":"type_to  <code>instance-attribute</code>","text":"<pre><code>type_to: type\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter.convert","title":"convert  <code>abstractmethod</code>","text":"<pre><code>convert(obj: Any) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>@abc.abstractmethod\ndef convert(self, obj: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.AbstractConverter.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.ConversionDispatcher","title":"ConversionDispatcher","text":"<pre><code>ConversionDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>converters</code>               (<code>list[AbstractConverter]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.converters = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.ConversionDispatcher.converters","title":"converters  <code>instance-attribute</code>","text":"<pre><code>converters: list[AbstractConverter] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.ConversionDispatcher.convert","title":"convert","text":"<pre><code>convert(obj: Any, type_to: type[_T]) -&gt; _T\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def convert(self, obj: Any, type_to: type[_T]) -&gt; _T:\n    if isinstance(obj, type_to):\n        return obj\n    for converter in self.converters:\n        if converter.match_from(obj) and converter.match_to(type_to):\n            return converter.convert(obj)\n    raise UnsupportedConversionError(obj, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.ConversionDispatcher.register","title":"register","text":"<pre><code>register(converter: AbstractConverter) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_dispatcher.py</code> <pre><code>def register(self, converter: AbstractConverter) -&gt; None:\n    bisect.insort(self.converters, converter, key=lambda c: c.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.UnsupportedConversionError","title":"UnsupportedConversionError","text":"<pre><code>UnsupportedConversionError(obj: Any, type_to: type)\n</code></pre> <p>               Bases: <code>TypeError</code></p> <p>Attributes:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            </li> <li> <code>type_to</code>               (<code>type</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_utils.py</code> <pre><code>def __init__(self, obj: Any, type_to: type) -&gt; None:\n    self.obj = obj\n    self.type_to = type_to\n    super().__init__(f\"Cannot convert `{obj}` to `{type_to}`.\")\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.UnsupportedConversionError.obj","title":"obj  <code>instance-attribute</code>","text":"<pre><code>obj: Any = obj\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.UnsupportedConversionError.type_to","title":"type_to  <code>instance-attribute</code>","text":"<pre><code>type_to: type = type_to\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/conversion/#liblaf.melon.io.dispatcher.conversion.warning_unsupported_association","title":"warning_unsupported_association","text":"<pre><code>warning_unsupported_association(\n    to: type,\n    association: FieldAssociation,\n    attr: Any | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_utils.py</code> <pre><code>def warning_unsupported_association(\n    to: type, association: pv.FieldAssociation, attr: Any | None = None\n) -&gt; None:\n    if attr is None:\n        return\n    logger.warning(\"{:r} does not support {:r} data\", to, association)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/","title":"liblaf.melon.io.dispatcher.reader","text":"<p>Classes:</p> <ul> <li> <code>AbstractReader</code>           \u2013            </li> <li> <code>ReaderDispatcher</code>           \u2013            </li> <li> <code>UnsupportedReaderError</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>load</code>           \u2013            </li> <li> <code>reader_dispatcher</code>           \u2013            </li> <li> <code>register_reader</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.load","title":"load  <code>module-attribute</code>","text":"<pre><code>load = load\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.reader_dispatcher","title":"reader_dispatcher  <code>module-attribute</code>","text":"<pre><code>reader_dispatcher = ReaderDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.register_reader","title":"register_reader  <code>module-attribute</code>","text":"<pre><code>register_reader = register\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.AbstractReader","title":"AbstractReader","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.AbstractReader.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.AbstractReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.AbstractReader.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>@abc.abstractmethod\ndef load(self, path: StrPath) -&gt; Any: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.AbstractReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.ReaderDispatcher","title":"ReaderDispatcher","text":"<pre><code>ReaderDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>readers</code>               (<code>list[AbstractReader]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.readers = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.ReaderDispatcher.readers","title":"readers  <code>instance-attribute</code>","text":"<pre><code>readers: list[AbstractReader] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.ReaderDispatcher.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def load(self, path: StrPath) -&gt; Any:\n    for reader in self.readers:\n        if reader.match_path(path):\n            return reader.load(path)\n    raise UnsupportedReaderError(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.ReaderDispatcher.register","title":"register","text":"<pre><code>register(reader: AbstractReader) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_dispatcher.py</code> <pre><code>def register(self, reader: AbstractReader) -&gt; None:\n    bisect.insort(self.readers, reader, key=lambda r: r.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.UnsupportedReaderError","title":"UnsupportedReaderError","text":"<pre><code>UnsupportedReaderError(path: StrPath)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_utils.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    self.path = Path(path)\n    super().__init__(f\"Cannot load `{self.path}`.\")\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/reader/#liblaf.melon.io.dispatcher.reader.UnsupportedReaderError.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/","title":"liblaf.melon.io.dispatcher.writer","text":"<p>Classes:</p> <ul> <li> <code>AbstractWriter</code>           \u2013            </li> <li> <code>UnsupportedWriterError</code>           \u2013            </li> <li> <code>WriterDispatcher</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>register_writer</code>           \u2013            </li> <li> <code>save</code>           \u2013            </li> <li> <code>writer_dispatcher</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.register_writer","title":"register_writer  <code>module-attribute</code>","text":"<pre><code>register_writer = register\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.save","title":"save  <code>module-attribute</code>","text":"<pre><code>save = save\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.writer_dispatcher","title":"writer_dispatcher  <code>module-attribute</code>","text":"<pre><code>writer_dispatcher = WriterDispatcher()\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.AbstractWriter","title":"AbstractWriter","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.AbstractWriter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.AbstractWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.AbstractWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.AbstractWriter.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>@abc.abstractmethod\ndef save(self, path: StrPath, obj: Any) -&gt; None: ...\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.UnsupportedWriterError","title":"UnsupportedWriterError","text":"<pre><code>UnsupportedWriterError(path: StrPath)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_utils.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    self.path = Path(path)\n    super().__init__(f\"Cannot save `{self.path}`.\")\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.UnsupportedWriterError.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.WriterDispatcher","title":"WriterDispatcher","text":"<pre><code>WriterDispatcher()\n</code></pre> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>writers</code>               (<code>list[AbstractWriter]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.writers = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.WriterDispatcher.writers","title":"writers  <code>instance-attribute</code>","text":"<pre><code>writers: list[AbstractWriter] = []\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.WriterDispatcher.register","title":"register","text":"<pre><code>register(writer: AbstractWriter) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def register(self, writer: AbstractWriter) -&gt; None:\n    bisect.insort(self.writers, writer, key=lambda r: r.priority)\n</code></pre>"},{"location":"api/liblaf/melon/io/dispatcher/writer/#liblaf.melon.io.dispatcher.writer.WriterDispatcher.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_dispatcher.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    for writer in self.writers:\n        if writer.match_path(path):\n            return writer.save(path, obj)\n    raise UnsupportedWriterError(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/","title":"liblaf.melon.io.melon","text":"<p>Modules:</p> <ul> <li> <code>dicom</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>DICOMReader</code>           \u2013            </li> <li> <code>DICOMWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_dicom</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMReader","title":"DICOMReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMReader.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; melon.DICOM:\n    return load_dicom(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return True\n    if path.is_file() and path.name == \"DIRFILE\":  # noqa: SIM103\n        return True\n    return False\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMWriter","title":"DICOMWriter","text":"<p>               Bases: <code>AbstractWriter</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMWriter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    if path.name == \"DIRFILE\":  # noqa: SIM103\n        return True\n    return False\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.DICOMWriter.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_writer.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    obj: melon.DICOM = as_dicom(obj)\n    obj.save(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.as_dicom","title":"as_dicom","text":"<pre><code>as_dicom(obj: Any) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/conversion/_as.py</code> <pre><code>def as_dicom(obj: Any) -&gt; melon.DICOM:\n    return conversion_dispatcher.convert(obj, melon.DICOM)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/#liblaf.melon.io.melon.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(path: StrPath) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def load_dicom(path: StrPath) -&gt; melon.DICOM:\n    return melon.DICOM(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/","title":"liblaf.melon.io.melon.dicom","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>DICOMReader</code>           \u2013            </li> <li> <code>DICOMWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_dicom</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMReader","title":"DICOMReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMReader.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; melon.DICOM:\n    return load_dicom(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return True\n    if path.is_file() and path.name == \"DIRFILE\":  # noqa: SIM103\n        return True\n    return False\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMWriter","title":"DICOMWriter","text":"<p>               Bases: <code>AbstractWriter</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMWriter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    if path.name == \"DIRFILE\":  # noqa: SIM103\n        return True\n    return False\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.DICOMWriter.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_writer.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    obj: melon.DICOM = as_dicom(obj)\n    obj.save(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.as_dicom","title":"as_dicom","text":"<pre><code>as_dicom(obj: Any) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/conversion/_as.py</code> <pre><code>def as_dicom(obj: Any) -&gt; melon.DICOM:\n    return conversion_dispatcher.convert(obj, melon.DICOM)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/#liblaf.melon.io.melon.dicom.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(path: StrPath) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/_reader.py</code> <pre><code>def load_dicom(path: StrPath) -&gt; melon.DICOM:\n    return melon.DICOM(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/melon/dicom/conversion/","title":"liblaf.melon.io.melon.dicom.conversion","text":"<p>Functions:</p> <ul> <li> <code>as_dicom</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/melon/dicom/conversion/#liblaf.melon.io.melon.dicom.conversion.as_dicom","title":"as_dicom","text":"<pre><code>as_dicom(obj: Any) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/io/melon/dicom/conversion/_as.py</code> <pre><code>def as_dicom(obj: Any) -&gt; melon.DICOM:\n    return conversion_dispatcher.convert(obj, melon.DICOM)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/","title":"liblaf.melon.io.pyvista","text":"<p>Modules:</p> <ul> <li> <code>image_data</code>           \u2013            </li> <li> <code>point_set</code>           \u2013            </li> <li> <code>poly_data</code>           \u2013            </li> <li> <code>unstructured_grid</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PolyDataReader</code>           \u2013            </li> <li> <code>PolyDataWriter</code>           \u2013            </li> <li> <code>UnstructuredGridReader</code>           \u2013            </li> <li> <code>UnstructuredGridWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_image_data</code>             \u2013              </li> <li> <code>as_point_set</code>             \u2013              </li> <li> <code>as_poly_data</code>             \u2013              </li> <li> <code>as_unstructured_grid</code>             \u2013              </li> <li> <code>load_image_data</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>load_unstructured_grid</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataReader","title":"PolyDataReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataReader.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {\n    \".obj\",\n    \".stl\",\n    \".vtp\",\n    \".ply\",\n}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; pv.PolyData:\n    return load_poly_data(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataWriter","title":"PolyDataWriter","text":"<p>               Bases: <code>AbstractWriter</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataWriter.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {\n    \".obj\",\n    \".stl\",\n    \".vtp\",\n    \".ply\",\n}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.PolyDataWriter.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_writer.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    path = Path(path)\n    obj: pv.PolyData = as_poly_data(obj)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.suffix == \".obj\":\n        save_obj(path, obj)\n    else:\n        obj.save(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridReader","title":"UnstructuredGridReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridReader.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {'.vtu'}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; pv.UnstructuredGrid:\n    return load_unstructured_grid(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridWriter","title":"UnstructuredGridWriter","text":"<p>               Bases: <code>AbstractWriter</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridWriter.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {'*.vtu'}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.UnstructuredGridWriter.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_writer.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    path = Path(path)\n    obj: pv.UnstructuredGrid = as_unstructured_grid(obj)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    obj.save(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_image_data","title":"as_image_data","text":"<pre><code>as_image_data(data: Any) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/conversion/_as.py</code> <pre><code>def as_image_data(data: Any) -&gt; pv.ImageData:\n    return conversion_dispatcher.convert(data, pv.ImageData)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_point_set","title":"as_point_set","text":"<pre><code>as_point_set(\n    data: Any, *, point_normals: bool = False\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_as.py</code> <pre><code>def as_point_set(data: Any, *, point_normals: bool = False) -&gt; pv.PointSet:\n    if point_normals:\n        return _as_point_set_with_normals(data)\n    return _as_point_set(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_poly_data","title":"as_poly_data","text":"<pre><code>as_poly_data(obj: Any) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/conversion/_as.py</code> <pre><code>def as_poly_data(obj: Any) -&gt; pv.PolyData:\n    return conversion_dispatcher.convert(obj, pv.PolyData)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_unstructured_grid","title":"as_unstructured_grid","text":"<pre><code>as_unstructured_grid(obj: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_as.py</code> <pre><code>def as_unstructured_grid(obj: Any) -&gt; pv.UnstructuredGrid:\n    return conversion_dispatcher.convert(obj, pv.UnstructuredGrid)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.load_image_data","title":"load_image_data","text":"<pre><code>load_image_data(path: StrPath) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/_reader.py</code> <pre><code>def load_image_data(path: StrPath) -&gt; pv.ImageData:\n    path = Path(path)\n    if path.is_file() and path.name == \"DIRFILE\":\n        path = path.parent\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return pv.read(path, force_ext=\".dcm\")  # pyright: ignore[reportReturnType]\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(path: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_reader.py</code> <pre><code>def load_poly_data(path: StrPath) -&gt; pv.PolyData:\n    path = Path(path)\n    if path.suffix == \".obj\":\n        return load_obj(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.load_unstructured_grid","title":"load_unstructured_grid","text":"<pre><code>load_unstructured_grid(path: StrPath) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_reader.py</code> <pre><code>def load_unstructured_grid(path: StrPath) -&gt; pv.UnstructuredGrid:\n    path = Path(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/","title":"liblaf.melon.io.pyvista.image_data","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ImageDataReader</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_image_data</code>             \u2013              </li> <li> <code>load_image_data</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.ImageDataReader","title":"ImageDataReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.ImageDataReader.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.ImageDataReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.ImageDataReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; pv.ImageData:\n    return load_image_data(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.ImageDataReader.match_path","title":"match_path","text":"<pre><code>match_path(path: str | PathLike[str]) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/_reader.py</code> <pre><code>def match_path(self, path: str | PathLike[str]) -&gt; bool:\n    path: Path = grapes.as_path(path)\n    if path.is_file() and path.name == \"DIRFILE\":\n        return True\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return True\n    return path.suffix in {\".dcm\", \".vti\"}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.as_image_data","title":"as_image_data","text":"<pre><code>as_image_data(data: Any) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/conversion/_as.py</code> <pre><code>def as_image_data(data: Any) -&gt; pv.ImageData:\n    return conversion_dispatcher.convert(data, pv.ImageData)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/#liblaf.melon.io.pyvista.image_data.load_image_data","title":"load_image_data","text":"<pre><code>load_image_data(path: StrPath) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/_reader.py</code> <pre><code>def load_image_data(path: StrPath) -&gt; pv.ImageData:\n    path = Path(path)\n    if path.is_file() and path.name == \"DIRFILE\":\n        path = path.parent\n    if path.is_dir() and (path / \"DIRFILE\").exists():\n        return pv.read(path, force_ext=\".dcm\")  # pyright: ignore[reportReturnType]\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/image_data/conversion/","title":"liblaf.melon.io.pyvista.image_data.conversion","text":"<p>Functions:</p> <ul> <li> <code>as_image_data</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/image_data/conversion/#liblaf.melon.io.pyvista.image_data.conversion.as_image_data","title":"as_image_data","text":"<pre><code>as_image_data(data: Any) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/image_data/conversion/_as.py</code> <pre><code>def as_image_data(data: Any) -&gt; pv.ImageData:\n    return conversion_dispatcher.convert(data, pv.ImageData)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/","title":"liblaf.melon.io.pyvista.point_set","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PolyDataToPointSet</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_point_set</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet","title":"PolyDataToPointSet","text":"<p>               Bases: <code>AbstractConverter</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>           \u2013            </li> <li> <code>type_to</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet.type_from","title":"type_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_from = PolyData\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet.type_to","title":"type_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_to = PointSet\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet.convert","title":"convert","text":"<pre><code>convert(obj: PolyData) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_poly_data.py</code> <pre><code>def convert(self, obj: pv.PolyData) -&gt; pv.PointSet:\n    return obj.cast_to_pointset()\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.PolyDataToPointSet.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/#liblaf.melon.io.pyvista.point_set.as_point_set","title":"as_point_set","text":"<pre><code>as_point_set(\n    data: Any, *, point_normals: bool = False\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_as.py</code> <pre><code>def as_point_set(data: Any, *, point_normals: bool = False) -&gt; pv.PointSet:\n    if point_normals:\n        return _as_point_set_with_normals(data)\n    return _as_point_set(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/","title":"liblaf.melon.io.pyvista.point_set.conversion","text":"<p>Classes:</p> <ul> <li> <code>PolyDataToPointSet</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_point_set</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet","title":"PolyDataToPointSet","text":"<p>               Bases: <code>AbstractConverter</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>           \u2013            </li> <li> <code>type_to</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet.type_from","title":"type_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_from = PolyData\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet.type_to","title":"type_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_to = PointSet\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet.convert","title":"convert","text":"<pre><code>convert(obj: PolyData) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_poly_data.py</code> <pre><code>def convert(self, obj: pv.PolyData) -&gt; pv.PointSet:\n    return obj.cast_to_pointset()\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.PolyDataToPointSet.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/point_set/conversion/#liblaf.melon.io.pyvista.point_set.conversion.as_point_set","title":"as_point_set","text":"<pre><code>as_point_set(\n    data: Any, *, point_normals: bool = False\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/point_set/conversion/_as.py</code> <pre><code>def as_point_set(data: Any, *, point_normals: bool = False) -&gt; pv.PointSet:\n    if point_normals:\n        return _as_point_set_with_normals(data)\n    return _as_point_set(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/","title":"liblaf.melon.io.pyvista.poly_data","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PolyDataReader</code>           \u2013            </li> <li> <code>PolyDataWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_poly_data</code>             \u2013              </li> <li> <code>load_obj</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save_obj</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataReader","title":"PolyDataReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataReader.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {\n    \".obj\",\n    \".stl\",\n    \".vtp\",\n    \".ply\",\n}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; pv.PolyData:\n    return load_poly_data(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataWriter","title":"PolyDataWriter","text":"<p>               Bases: <code>AbstractWriter</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataWriter.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {\n    \".obj\",\n    \".stl\",\n    \".vtp\",\n    \".ply\",\n}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.PolyDataWriter.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_writer.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    path = Path(path)\n    obj: pv.PolyData = as_poly_data(obj)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.suffix == \".obj\":\n        save_obj(path, obj)\n    else:\n        obj.save(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.as_poly_data","title":"as_poly_data","text":"<pre><code>as_poly_data(obj: Any) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/conversion/_as.py</code> <pre><code>def as_poly_data(obj: Any) -&gt; pv.PolyData:\n    return conversion_dispatcher.convert(obj, pv.PolyData)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.load_obj","title":"load_obj","text":"<pre><code>load_obj(fpath: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_load_obj.py</code> <pre><code>def load_obj(fpath: StrPath) -&gt; pv.PolyData:\n    path: Path = Path(fpath)\n    points: list[list[float]] = []\n    faces: list[list[int]] = []\n    group_ids: list[int] = []\n    group_names: list[str] = []\n    current_group_id: int = 0\n    for line in grapes.strip_comments(path.read_text()):\n        cmd: str\n        values: list[str]\n        cmd, *values = line.split()\n        match cmd:\n            case \"v\":\n                points.append([float(v) for v in values])\n            case \"f\":\n                faces.append(_parse_f(values))\n                if len(group_names) == 0:\n                    group_names.append(\"\")\n                group_ids.append(current_group_id)\n            case \"g\":\n                if len(values) &gt;= 1:\n                    if (name := values[0]) in group_names:\n                        current_group_id = group_names.index(name)\n                    else:\n                        group_names.append(name)\n                        current_group_id = len(group_names) - 1\n                else:\n                    group_names.append(\"\")\n                    current_group_id = len(group_names) - 1\n            case \"vt\" | \"vn\":\n                # TODO: load `vt`, `vn`\n                pass\n            case _:\n                grapes.warning_once(\"Unknown element: {}\", line)\n    mesh: pv.PolyData = pv.PolyData.from_irregular_faces(points, faces)\n    if len(group_names) &gt; 1 or group_names[0] != \"\":\n        mesh.cell_data[\"GroupIds\"] = group_ids\n        mesh.field_data[\"GroupNames\"] = group_names\n    return mesh\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(path: StrPath) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_reader.py</code> <pre><code>def load_poly_data(path: StrPath) -&gt; pv.PolyData:\n    path = Path(path)\n    if path.suffix == \".obj\":\n        return load_obj(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/#liblaf.melon.io.pyvista.poly_data.save_obj","title":"save_obj","text":"<pre><code>save_obj(path: StrPath, mesh: PolyData) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/_save_obj.py</code> <pre><code>def save_obj(path: StrPath, mesh: pv.PolyData) -&gt; None:\n    if not has_groups(mesh):\n        mesh.save(path)\n    with Path(path).open(\"w\") as fp:\n        fprint = functools.partial(print, file=fp)\n        for v in mesh.points:\n            fprint(\"v\", *v)\n        if \"GroupIds\" in mesh.cell_data:\n            group_ids: Integer[np.ndarray, \" N\"] = mesh.cell_data[\"GroupIds\"]\n            if \"GroupNames\" in mesh.field_data:\n                group_names = mesh.field_data[\"GroupNames\"]\n            else:\n                group_names = collections.defaultdict(str)\n            last_group_id: int = -1\n            for f, group_id in zip(mesh.irregular_faces, group_ids, strict=True):\n                if group_id != last_group_id:\n                    group_name: str = group_names[group_id]  # pyright: ignore[reportAssignmentType]\n                    if group_name:\n                        fprint(\"g\", group_name)\n                    else:\n                        fprint(\"g\")\n                    last_group_id = group_id\n                fprint(\"f\", *[v + 1 for v in f])\n        else:\n            for f in mesh.irregular_faces:\n                fprint(\"f\", *[v + 1 for v in f])\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/","title":"liblaf.melon.io.pyvista.poly_data.conversion","text":"<p>Classes:</p> <ul> <li> <code>MappingToPolyData</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_poly_data</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData","title":"MappingToPolyData","text":"<p>               Bases: <code>AbstractConverter</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>           \u2013            </li> <li> <code>type_to</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData.type_from","title":"type_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_from = Mapping\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData.type_to","title":"type_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_to = PolyData\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData.convert","title":"convert","text":"<pre><code>convert(obj: Mapping) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/conversion/_mapping.py</code> <pre><code>def convert(self, obj: Mapping) -&gt; pv.PolyData:\n    return pv.PolyData.from_regular_faces(\n        obj[\"points\"], glom.glom(obj, glom.Coalesce(\"faces\", \"cells\"))\n    )\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.MappingToPolyData.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/poly_data/conversion/#liblaf.melon.io.pyvista.poly_data.conversion.as_poly_data","title":"as_poly_data","text":"<pre><code>as_poly_data(obj: Any) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/poly_data/conversion/_as.py</code> <pre><code>def as_poly_data(obj: Any) -&gt; pv.PolyData:\n    return conversion_dispatcher.convert(obj, pv.PolyData)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/","title":"liblaf.melon.io.pyvista.unstructured_grid","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>MappingToUnstructuredGrid</code>           \u2013            </li> <li> <code>UnstructuredGridReader</code>           \u2013            </li> <li> <code>UnstructuredGridWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_unstructured_grid</code>             \u2013              </li> <li> <code>load_unstructured_grid</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid","title":"MappingToUnstructuredGrid","text":"<p>               Bases: <code>AbstractConverter</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>           \u2013            </li> <li> <code>type_to</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid.type_from","title":"type_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_from = Mapping\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid.type_to","title":"type_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_to = UnstructuredGrid\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid.convert","title":"convert","text":"<pre><code>convert(obj: Mapping) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_mapping.py</code> <pre><code>def convert(self, obj: Mapping) -&gt; pv.UnstructuredGrid:\n    return pv.UnstructuredGrid(\n        {pv.CellType.TETRA: glom.glom(obj, glom.Coalesce(\"tetras\", \"cells\"))},\n        obj[\"points\"],\n    )\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.MappingToUnstructuredGrid.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridReader","title":"UnstructuredGridReader","text":"<p>               Bases: <code>AbstractReader</code></p> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              </li> <li> <code>match_path</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridReader.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {'.vtu'}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridReader.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridReader.load","title":"load","text":"<pre><code>load(path: StrPath) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_reader.py</code> <pre><code>def load(self, path: StrPath) -&gt; pv.UnstructuredGrid:\n    return load_unstructured_grid(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridReader.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/reader/_reader.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridWriter","title":"UnstructuredGridWriter","text":"<p>               Bases: <code>AbstractWriter</code></p> <p>Methods:</p> <ul> <li> <code>match_path</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>Container[str]</code>)           \u2013            </li> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridWriter.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Container[str] = {'*.vtu'}\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridWriter.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridWriter.match_path","title":"match_path","text":"<pre><code>match_path(path: StrPath) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/writer/_writer.py</code> <pre><code>def match_path(self, path: StrPath) -&gt; bool:\n    path = Path(path)\n    return path.suffix in self.extensions\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.UnstructuredGridWriter.save","title":"save","text":"<pre><code>save(path: StrPath, obj: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_writer.py</code> <pre><code>def save(self, path: StrPath, obj: Any) -&gt; None:\n    path = Path(path)\n    obj: pv.UnstructuredGrid = as_unstructured_grid(obj)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    obj.save(path)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.as_unstructured_grid","title":"as_unstructured_grid","text":"<pre><code>as_unstructured_grid(obj: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_as.py</code> <pre><code>def as_unstructured_grid(obj: Any) -&gt; pv.UnstructuredGrid:\n    return conversion_dispatcher.convert(obj, pv.UnstructuredGrid)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.load_unstructured_grid","title":"load_unstructured_grid","text":"<pre><code>load_unstructured_grid(path: StrPath) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_reader.py</code> <pre><code>def load_unstructured_grid(path: StrPath) -&gt; pv.UnstructuredGrid:\n    path = Path(path)\n    return pv.read(path)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/","title":"liblaf.melon.io.pyvista.unstructured_grid.conversion","text":"<p>Classes:</p> <ul> <li> <code>MappingToUnstructuredGrid</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_unstructured_grid</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid","title":"MappingToUnstructuredGrid","text":"<p>               Bases: <code>AbstractConverter</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>           \u2013            </li> <li> <code>type_to</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid.type_from","title":"type_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_from = Mapping\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid.type_to","title":"type_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_to = UnstructuredGrid\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid.convert","title":"convert","text":"<pre><code>convert(obj: Mapping) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_mapping.py</code> <pre><code>def convert(self, obj: Mapping) -&gt; pv.UnstructuredGrid:\n    return pv.UnstructuredGrid(\n        {pv.CellType.TETRA: glom.glom(obj, glom.Coalesce(\"tetras\", \"cells\"))},\n        obj[\"points\"],\n    )\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.MappingToUnstructuredGrid.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/pyvista/unstructured_grid/conversion/#liblaf.melon.io.pyvista.unstructured_grid.conversion.as_unstructured_grid","title":"as_unstructured_grid","text":"<pre><code>as_unstructured_grid(obj: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/conversion/_as.py</code> <pre><code>def as_unstructured_grid(obj: Any) -&gt; pv.UnstructuredGrid:\n    return conversion_dispatcher.convert(obj, pv.UnstructuredGrid)\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/","title":"liblaf.melon.io.trimesh","text":"<p>Modules:</p> <ul> <li> <code>trimesh</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_trimesh</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/trimesh/#liblaf.melon.io.trimesh.as_trimesh","title":"as_trimesh","text":"<pre><code>as_trimesh(data: Any) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/trimesh/conversion/_as.py</code> <pre><code>def as_trimesh(data: Any) -&gt; tm.Trimesh:\n    return conversion_dispatcher.convert(data, tm.Trimesh)\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/","title":"liblaf.melon.io.trimesh.trimesh","text":"<p>Modules:</p> <ul> <li> <code>conversion</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_trimesh</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/#liblaf.melon.io.trimesh.trimesh.as_trimesh","title":"as_trimesh","text":"<pre><code>as_trimesh(data: Any) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/trimesh/conversion/_as.py</code> <pre><code>def as_trimesh(data: Any) -&gt; tm.Trimesh:\n    return conversion_dispatcher.convert(data, tm.Trimesh)\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/","title":"liblaf.melon.io.trimesh.trimesh.conversion","text":"<p>Classes:</p> <ul> <li> <code>PolyDataToTrimesh</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_trimesh</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh","title":"PolyDataToTrimesh","text":"<p>               Bases: <code>AbstractConverter</code></p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>match_from</code>             \u2013              </li> <li> <code>match_to</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>priority</code>               (<code>int</code>)           \u2013            </li> <li> <code>type_from</code>           \u2013            </li> <li> <code>type_to</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh.type_from","title":"type_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_from = PolyData\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh.type_to","title":"type_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type_to = Trimesh\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh.convert","title":"convert","text":"<pre><code>convert(obj: PolyData) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/trimesh/conversion/_poly_data.py</code> <pre><code>def convert(self, obj: pv.PolyData) -&gt; tm.Trimesh:\n    obj = obj.triangulate()  # pyright: ignore[reportAssignmentType]\n    return tm.Trimesh(obj.points, obj.regular_faces)\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh.match_from","title":"match_from","text":"<pre><code>match_from(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_from(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self.type_from)\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.PolyDataToTrimesh.match_to","title":"match_to","text":"<pre><code>match_to(type_to: type) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/io/dispatcher/conversion/_converter.py</code> <pre><code>def match_to(self, type_to: type) -&gt; bool:\n    return issubclass(self.type_to, type_to)\n</code></pre>"},{"location":"api/liblaf/melon/io/trimesh/trimesh/conversion/#liblaf.melon.io.trimesh.trimesh.conversion.as_trimesh","title":"as_trimesh","text":"<pre><code>as_trimesh(data: Any) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/trimesh/conversion/_as.py</code> <pre><code>def as_trimesh(data: Any) -&gt; tm.Trimesh:\n    return conversion_dispatcher.convert(data, tm.Trimesh)\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/","title":"liblaf.melon.io.wrap","text":"<p>Modules:</p> <ul> <li> <code>landmarks</code>           \u2013            </li> <li> <code>polygons</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(path: StrPath) -&gt; Float[ndarray, 'N 3']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: StrPath) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    data: list[dict[str, float]] = grapes.deserialize(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: StrPath) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: StrPath) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.deserialize(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: StrPath, points: Float[ArrayLike, \"N 3\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(path: StrPath, points: Float[ArrayLike, \"N 3\"]) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [{\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points]\n    grapes.serialize(path, data)\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: StrPath, polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(path: StrPath, polygons: Integer[ArrayLike, \" N\"]) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.serialize(path, polygons.tolist())\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/landmarks/","title":"liblaf.melon.io.wrap.landmarks","text":"<p>Functions:</p> <ul> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(path: StrPath) -&gt; Float[ndarray, 'N 3']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: StrPath) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    data: list[dict[str, float]] = grapes.deserialize(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: StrPath, points: Float[ArrayLike, \"N 3\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(path: StrPath, points: Float[ArrayLike, \"N 3\"]) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [{\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points]\n    grapes.serialize(path, data)\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/polygons/","title":"liblaf.melon.io.wrap.polygons","text":"<p>Functions:</p> <ul> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: StrPath) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: StrPath) -&gt; Path:\n    path = Path(path)\n    if path.suffix in melon.io.SUFFIXES:\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: StrPath) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: StrPath) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.deserialize(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"api/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: StrPath, polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(path: StrPath, polygons: Integer[ArrayLike, \" N\"]) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.serialize(path, polygons.tolist())\n</code></pre>"},{"location":"api/liblaf/melon/ops/","title":"liblaf.melon.ops","text":"<p>Modules:</p> <ul> <li> <code>correspondence</code>           \u2013            </li> <li> <code>pyvista</code>           \u2013            </li> <li> <code>registration</code>           \u2013            </li> <li> <code>selection</code>           \u2013            </li> <li> <code>transfer</code>           \u2013            </li> <li> <code>transformations</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>NearestPointOnSurface</code>           \u2013            </li> <li> <code>NearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>NearestPointOnSurfaceResult</code>           \u2013            </li> <li> <code>NearestVertex</code>           \u2013            </li> <li> <code>NearestVertexPrepared</code>           \u2013            </li> <li> <code>NearestVertexResult</code>           \u2013            </li> <li> <code>RigidICP</code>           \u2013            </li> <li> <code>RigidRegistrationAlgorithm</code>           \u2013            </li> <li> <code>RigidRegistrationResult</code>           \u2013            </li> <li> <code>TransferAlgorithm</code>           \u2013            </li> <li> <code>TransferAlgorithmPrepared</code>           \u2013            </li> <li> <code>TransferAuto</code>           \u2013            </li> <li> <code>TransferAutoPrepared</code>           \u2013            </li> <li> <code>TransferNearestPointOnSurface</code>           \u2013            </li> <li> <code>TransferNearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>TransferNearestVertex</code>           \u2013            </li> <li> <code>TransferNearestVertexPrepared</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>concat_transforms</code>             \u2013              </li> <li> <code>contour</code>             \u2013              </li> <li> <code>ensure_positive_volume</code>             \u2013              </li> <li> <code>extract_points</code>             \u2013              </li> <li> <code>gaussian_smooth</code>             \u2013              </li> <li> <code>get_fill_value</code>             \u2013              </li> <li> <code>nearest_point_on_surface</code>             \u2013              </li> <li> <code>nearest_vertex</code>             \u2013              </li> <li> <code>rigid_align</code>             \u2013              </li> <li> <code>transfer_point_to_point</code>             \u2013              </li> <li> <code>transform</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface","title":"NearestPointOnSurface","text":"<p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def prepare(self, source: Any) -&gt; NearestPointOnSurfacePrepared:\n    source: tm.Trimesh = melon.as_trimesh(source)\n    return NearestPointOnSurfacePrepared(\n        distance_threshold=self.distance_threshold,\n        fallback_to_nearest_vertex=self.fallback_to_nearest_vertex,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared","title":"NearestPointOnSurfacePrepared","text":"<p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: Trimesh\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfacePrepared.query","title":"query","text":"<pre><code>query(target: Any) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def query(self, target: Any) -&gt; NearestPointOnSurfaceResult:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    target: pv.PointSet = melon.as_point_set(target, point_normals=need_normals)\n    nearest: Float[np.ndarray, \"N 3\"]\n    distance: Float[np.ndarray, \" N\"]\n    triangle_id: Integer[np.ndarray, \" N\"]\n    nearest, distance, triangle_id = self.source.nearest.on_surface(target.points)\n    missing: Bool[np.ndarray, \" N\"] = (\n        distance &gt; self.distance_threshold * self.source.scale\n    )\n    if need_normals:\n        source_normals: Float[np.ndarray, \"N 3\"] = self.source.face_normals[\n            triangle_id\n        ]\n        target_normals: Float[np.ndarray, \"N 3\"] = target.point_data[\"Normals\"]\n        normal_similarity: Float[np.ndarray, \" N\"] = np.vecdot(\n            source_normals, target_normals\n        )\n        missing |= normal_similarity &lt; self.normal_threshold\n    distance[missing] = np.inf\n    nearest[missing] = np.nan\n    triangle_id[missing] = -1\n    result = NearestPointOnSurfaceResult(\n        distance=distance, missing=missing, nearest=nearest, triangle_id=triangle_id\n    )\n    if self.fallback_to_nearest_vertex:\n        result = self._fallback_to_nearest_vertex(target, result)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfaceResult","title":"NearestPointOnSurfaceResult","text":"<p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' N']</code>)           \u2013            <p>(N,) float</p> </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' N']</code>)           \u2013            <p>(N,) bool</p> </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'N 3']</code>)           \u2013            <p>(N, 3) float</p> </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            <p>(N,) int</p> </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfaceResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' N']\n</code></pre> <p>(N,) float</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfaceResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' N']\n</code></pre> <p>(N,) bool</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfaceResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'N 3']\n</code></pre> <p>(N, 3) float</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestPointOnSurfaceResult.triangle_id","title":"triangle_id  <code>instance-attribute</code>","text":"<pre><code>triangle_id: Integer[ndarray, ' N']\n</code></pre> <p>(N,) int</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertex","title":"NearestVertex","text":"<p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertex.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertex.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertex.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertex.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertex.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestVertexPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def prepare(self, source: Any) -&gt; NearestVertexPrepared:\n    source: pv.PointSet = melon.as_point_set(\n        source, point_normals=self.normal_threshold &gt; -1.0\n    )\n    tree = KDTree(source.points)\n    return NearestVertexPrepared(\n        distance_threshold=self.distance_threshold,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n        tree=tree,\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared","title":"NearestVertexPrepared","text":"<p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: PointSet\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.tree","title":"tree  <code>instance-attribute</code>","text":"<pre><code>tree: KDTree\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexPrepared.query","title":"query","text":"<pre><code>query(target: Any) -&gt; NearestVertexResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def query(self, target: Any) -&gt; NearestVertexResult:\n    if self.normal_threshold &lt;= -1.0:\n        return self._nearest_vertex(target)\n    return self._nearest_vertex_with_normal_threshold(target)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexResult","title":"NearestVertexResult","text":"<p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' N']</code>)           \u2013            <p>(N,) float</p> </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' N']</code>)           \u2013            <p>(N,) bool</p> </li> <li> <code>nearest</code>               (<code>Float[ndarray, ' N 3']</code>)           \u2013            <p>(N, 3) float</p> </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            <p>(N,) int</p> </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' N']\n</code></pre> <p>(N,) float</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' N']\n</code></pre> <p>(N,) bool</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, ' N 3']\n</code></pre> <p>(N, 3) float</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.NearestVertexResult.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' N']\n</code></pre> <p>(N,) int</p>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP","title":"RigidICP","text":"<p>               Bases: <code>RigidRegistrationAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>corresp_algo</code>               (<code>NearestVertex</code>)           \u2013            </li> <li> <code>loss_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_iters</code>               (<code>int</code>)           \u2013            </li> <li> <code>reflection</code>               (<code>bool</code>)           \u2013            </li> <li> <code>scale</code>               (<code>bool</code>)           \u2013            </li> <li> <code>translation</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.corresp_algo","title":"corresp_algo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>corresp_algo: NearestVertex = field(factory=NearestVertex)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.loss_threshold","title":"loss_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loss_threshold: float = 1e-06\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.max_iters","title":"max_iters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_iters: int = 100\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scale: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.translation","title":"translation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>translation: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidICP.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_icp.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult:\n    corresp_algo_prepared: melon.NearestVertexPrepared = self.corresp_algo.prepare(\n        target\n    )\n    source: pv.PolyData = melon.as_poly_data(source)\n    target: pv.PolyData = melon.as_poly_data(target)\n    init_transform: Float[np.ndarray, \"4 4\"] = np.asarray(init_transform)\n    result = RigidRegistrationResult(\n        init_transform=init_transform,\n        loss=np.nan,\n        transformation=init_transform,\n        history=[np.eye(4)],\n    )\n    source_weights: Float[np.ndarray, \" N\"] | None = source.point_data.get(\n        \"Weights\"\n    )\n    target_weights: Float[np.ndarray, \" N\"] | None = target.point_data.get(\n        \"Weights\"\n    )\n    for it in range(self.max_iters):\n        transformed: pv.PolyData = source.transform(\n            result.transformation, inplace=False\n        )  # pyright: ignore[reportAssignmentType]\n        corresp: melon.NearestVertexResult = corresp_algo_prepared.query(\n            transformed\n        )\n        valid_mask: Bool[np.ndarray, \" N\"] = ~corresp.missing\n        matrix: Float[np.ndarray, \"4 4\"]\n        cost: float\n        source_points: Float[np.ndarray, \"N 3\"] = transformed.points[valid_mask]\n        target_points: Float[np.ndarray, \"N 3\"] = corresp.nearest[valid_mask]\n        weights: Float[np.ndarray, \" N\"] = np.ones((source_points.shape[0],))\n        if source_weights:\n            weights *= source_weights[valid_mask]\n        if target_weights:\n            weights *= target_weights[corresp.vertex_id[valid_mask]]\n        matrix, _, cost = tm.registration.procrustes(\n            source_points,\n            target_points,\n            weights=weights,\n            reflection=self.reflection,\n            translation=self.translation,\n            scale=self.scale,\n            return_cost=True,\n        )\n        last_loss: float = result.loss\n        result.loss = cost\n        result.transformation = matrix @ result.transformation\n        result.history.append(result.transformation)\n        # log loss metric\n        logger.debug(\"ICP (it: {}) &gt; loss: {}\", it, cost)\n        if last_loss - cost &lt; self.loss_threshold:\n            break\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationAlgorithm","title":"RigidRegistrationAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationAlgorithm.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_abc.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationResult","title":"RigidRegistrationResult","text":"<p>Attributes:</p> <ul> <li> <code>history</code>               (<code>list[Float[ndarray, '4 4']]</code>)           \u2013            </li> <li> <code>init_transform</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> <li> <code>loss</code>               (<code>float</code>)           \u2013            </li> <li> <code>transformation</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationResult.history","title":"history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history: list[Float[ndarray, '4 4']] = field(factory=list)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationResult.init_transform","title":"init_transform  <code>instance-attribute</code>","text":"<pre><code>init_transform: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationResult.loss","title":"loss  <code>instance-attribute</code>","text":"<pre><code>loss: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.RigidRegistrationResult.transformation","title":"transformation  <code>instance-attribute</code>","text":"<pre><code>transformation: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAlgorithm","title":"TransferAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAlgorithm.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferAlgorithmPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_abc.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferAlgorithmPrepared: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAlgorithmPrepared","title":"TransferAlgorithmPrepared","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAlgorithmPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Shaped[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_abc.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Shaped[np.ndarray, \"target_points ...\"]: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAuto","title":"TransferAuto","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>categorial</code>               (<code>TransferAlgorithm</code>)           \u2013            </li> <li> <code>floating</code>               (<code>TransferAlgorithm</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAuto.categorial","title":"categorial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>categorial: TransferAlgorithm = field(\n    factory=TransferNearestVertex\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAuto.floating","title":"floating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>floating: TransferAlgorithm = field(\n    factory=TransferNearestPointOnSurface\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAuto.prepare","title":"prepare","text":"<pre><code>prepare(source: Any, target: Any) -&gt; TransferAutoPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_auto.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferAutoPrepared:\n    return TransferAutoPrepared(\n        floating=self.floating.prepare(source, target),\n        categorial=self.categorial.prepare(source, target),\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAutoPrepared","title":"TransferAutoPrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>categorial</code>               (<code>TransferAlgorithmPrepared</code>)           \u2013            </li> <li> <code>floating</code>               (<code>TransferAlgorithmPrepared</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAutoPrepared.categorial","title":"categorial  <code>instance-attribute</code>","text":"<pre><code>categorial: TransferAlgorithmPrepared\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAutoPrepared.floating","title":"floating  <code>instance-attribute</code>","text":"<pre><code>floating: TransferAlgorithmPrepared\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferAutoPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Shaped[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_auto.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Shaped[np.ndarray, \"target_points ...\"]:\n    data: Shaped[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    if np.isdtype(data.dtype, (\"bool\", \"integer\")):\n        return self.categorial.transfer(data, fill_value)\n    return self.floating.transfer(data, fill_value)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurface","title":"TransferNearestPointOnSurface","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = 0.8\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferNearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_point_on_surface.py</code> <pre><code>def prepare(\n    self, source: Any, target: Any\n) -&gt; TransferNearestPointOnSurfacePrepared:\n    source: tm.Trimesh = melon.as_trimesh(source)\n    corresp: melon.NearestPointOnSurfaceResult = melon.nearest_point_on_surface(\n        source,\n        target,\n        distance_threshold=self.distance_threshold,\n        normal_threshold=self.normal_threshold,\n    )\n    triangles: Integer[np.ndarray, \"target_points 3\"] = source.faces[\n        corresp.triangle_id\n    ]\n    barycentric: Float[np.ndarray, \"target_points 3\"] = (\n        tm.triangles.points_to_barycentric(\n            source.vertices[triangles], corresp.nearest\n        )\n    )\n    barycentric[corresp.missing] = np.nan\n    triangles[corresp.missing] = -1\n    return TransferNearestPointOnSurfacePrepared(\n        barycentric=barycentric, missing=corresp.missing, triangles=triangles\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurfacePrepared","title":"TransferNearestPointOnSurfacePrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>barycentric</code>               (<code>Float[ndarray, 'target_points 3']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' target_points']</code>)           \u2013            </li> <li> <code>triangles</code>               (<code>Integer[ndarray, 'target_points 3']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurfacePrepared.barycentric","title":"barycentric  <code>instance-attribute</code>","text":"<pre><code>barycentric: Float[ndarray, 'target_points 3']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurfacePrepared.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurfacePrepared.triangles","title":"triangles  <code>instance-attribute</code>","text":"<pre><code>triangles: Integer[ndarray, 'target_points 3']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestPointOnSurfacePrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Float[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_point_on_surface.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Float[np.ndarray, \"target_points ...\"]:\n    data: Float[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    result: Float[np.ndarray, \"target_points ...\"] = np.einsum(\n        \"ij,ij...-&gt;i...\", self.barycentric, data[self.triangles], dtype=data.dtype\n    )\n    result[self.missing] = fill_value\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertex","title":"TransferNearestVertex","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_upper_bound</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertex.distance_upper_bound","title":"distance_upper_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_upper_bound: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertex.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertex.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = 0.8\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertex.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertex.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferNearestVertexPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_vertex.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferNearestVertexPrepared:\n    corresp: melon.NearestVertexResult = melon.nearest_vertex(\n        source,\n        target,\n        distance_threshold=self.distance_upper_bound,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n    )\n    return TransferNearestVertexPrepared(\n        missing=corresp.missing, vertex_id=corresp.vertex_id\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertexPrepared","title":"TransferNearestVertexPrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>missing</code>               (<code>Bool[ndarray, ' target_points']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' target_points']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertexPrepared.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertexPrepared.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.TransferNearestVertexPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_vertex.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Any:\n    data: Num[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    result: Shaped[np.ndarray, \"target_points ...\"] = data[self.vertex_id].copy()\n    result[self.missing] = fill_value\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.concat_transforms","title":"concat_transforms","text":"<pre><code>concat_transforms(\n    *transform: Float[ArrayLike, \"4 4\"] | None,\n) -&gt; Float[ndarray, \"4 4\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transformations/_concat.py</code> <pre><code>def concat_transforms(\n    *transform: Float[ArrayLike, \"4 4\"] | None,\n) -&gt; Float[np.ndarray, \"4 4\"]:\n    result: Float[np.ndarray, \"4 4\"] = np.eye(4)\n    for t in transform:\n        if t is None:\n            continue\n        result = result @ np.asarray(t)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.contour","title":"contour","text":"<pre><code>contour(\n    data: Any,\n    isosurfaces: int | Sequence[float] | None = None,\n    scalars: str | Float[ArrayLike, ...] | None = None,\n    *,\n    compute_normals: bool = False,\n    compute_gradients: bool = False,\n    compute_scalars: bool = True,\n    rng: Sequence[float] | None = None,\n    preference: Literal[\"point\", \"cell\"] = \"point\",\n    method: Literal[\n        \"contour\", \"marching_cubes\", \"flying_edges\"\n    ] = \"contour\",\n    progress_bar: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_contour.py</code> <pre><code>def contour(\n    data: Any,\n    isosurfaces: int | Sequence[float] | None = None,\n    scalars: str | Float[ArrayLike, \"...\"] | None = None,\n    *,\n    compute_normals: bool = False,\n    compute_gradients: bool = False,\n    compute_scalars: bool = True,\n    rng: Sequence[float] | None = None,\n    preference: Literal[\"point\", \"cell\"] = \"point\",\n    method: Literal[\"contour\", \"marching_cubes\", \"flying_edges\"] = \"contour\",\n    progress_bar: bool = False,\n) -&gt; pv.PolyData:\n    data: pv.ImageData = melon.as_image_data(data)\n    result: pv.PolyData = data.contour(  # pyright: ignore[reportAssignmentType]\n        isosurfaces=isosurfaces,  # pyright: ignore[reportArgumentType]\n        scalars=scalars,\n        compute_normals=compute_normals,\n        compute_gradients=compute_gradients,\n        compute_scalars=compute_scalars,\n        rng=rng,\n        preference=preference,\n        method=method,\n        progress_bar=progress_bar,\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.ensure_positive_volume","title":"ensure_positive_volume","text":"<pre><code>ensure_positive_volume(mesh: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_tetra.py</code> <pre><code>def ensure_positive_volume(mesh: Any) -&gt; pv.UnstructuredGrid:\n    mesh: pv.UnstructuredGrid = melon.as_unstructured_grid(mesh)\n    mesh = mesh.compute_cell_sizes(\n        length=False, area=False, volume=True, vertex_count=False\n    )  # pyright: ignore[reportAssignmentType]\n    return flip(mesh, mask=mesh.cell_data[\"Volume\"] &lt; 0)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.extract_points","title":"extract_points","text":"<pre><code>extract_points(\n    data: Any,\n    ind: Bool[ArrayLike, \" N\"] | Integer[ArrayLike, \" N\"],\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_extract_points.py</code> <pre><code>def extract_points(\n    data: Any, ind: Bool[ArrayLike, \" N\"] | Integer[ArrayLike, \" N\"]\n) -&gt; pv.PointSet:\n    data: pv.PointSet = melon.as_point_set(data)\n    unstructured: pv.UnstructuredGrid = data.extract_points(ind)  # pyright: ignore[reportAssignmentType]\n    return melon.as_point_set(unstructured)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.gaussian_smooth","title":"gaussian_smooth","text":"<pre><code>gaussian_smooth(\n    data: Any,\n    radius_factor: float | Sequence[float] = 1.5,\n    std_dev: float | Sequence[float] = 2.0,\n    scalars: str | None = None,\n    *,\n    progress_bar: bool = False,\n) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_gaussian_smooth.py</code> <pre><code>def gaussian_smooth(\n    data: Any,\n    radius_factor: float | Sequence[float] = 1.5,\n    std_dev: float | Sequence[float] = 2.0,\n    scalars: str | None = None,\n    *,\n    progress_bar: bool = False,\n) -&gt; pv.ImageData:\n    data: pv.ImageData = melon.as_image_data(data)\n    result: pv.ImageData = data.gaussian_smooth(  # pyright: ignore[reportAssignmentType]\n        radius_factor=radius_factor,  # pyright: ignore[reportArgumentType]\n        std_dev=std_dev,  # pyright: ignore[reportArgumentType]\n        scalars=scalars,\n        progress_bar=progress_bar,\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.get_fill_value","title":"get_fill_value","text":"<pre><code>get_fill_value(\n    dtype: DTypeLike, fill_value: ScalarLike | None = None\n) -&gt; ScalarLike\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_utils.py</code> <pre><code>def get_fill_value(\n    dtype: DTypeLike, fill_value: ScalarLike | None = None\n) -&gt; ScalarLike:\n    if fill_value is not None:\n        return fill_value\n    return np.zeros((), dtype=dtype).item()\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.nearest_point_on_surface","title":"nearest_point_on_surface","text":"<pre><code>nearest_point_on_surface(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    fallback_to_nearest_vertex: bool = False,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def nearest_point_on_surface(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    fallback_to_nearest_vertex: bool = False,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestPointOnSurfaceResult:\n    algorithm = NearestPointOnSurface(\n        distance_threshold=distance_threshold,\n        fallback_to_nearest_vertex=fallback_to_nearest_vertex,\n        max_k=max_k,\n        normal_threshold=normal_threshold,\n        workers=workers,\n    )\n    prepared: NearestPointOnSurfacePrepared = algorithm.prepare(source)\n    return prepared.query(target)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.nearest_vertex","title":"nearest_vertex","text":"<pre><code>nearest_vertex(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestVertexResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def nearest_vertex(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestVertexResult:\n    algorithm = NearestVertex(\n        distance_threshold=distance_threshold,\n        max_k=max_k,\n        normal_threshold=normal_threshold,\n        workers=workers,\n    )\n    prepared: NearestVertexPrepared = algorithm.prepare(source)\n    return prepared.query(target)\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.rigid_align","title":"rigid_align","text":"<pre><code>rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_main.py</code> <pre><code>def rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult:\n    algorithm = algorithm or RigidICP()\n    init_transform = np.eye(4) if init_transform is None else init_transform\n    result: RigidRegistrationResult = algorithm.register(\n        source, target, init_transform=init_transform\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.transfer_point_to_point","title":"transfer_point_to_point","text":"<pre><code>transfer_point_to_point(\n    source: Any,\n    target: Any,\n    data: Iterable[str],\n    *,\n    algo: TransferAlgorithm | None = None,\n    fill_value: ScalarLike\n    | Mapping[str, ScalarLike | None]\n    | None = None,\n) -&gt; Attrs\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_transfer.py</code> <pre><code>def transfer_point_to_point(\n    source: Any,\n    target: Any,\n    data: Iterable[str],\n    *,\n    algo: TransferAlgorithm | None = None,\n    fill_value: ScalarLike | Mapping[str, ScalarLike | None] | None = None,\n) -&gt; Attrs:\n    if algo is None:\n        algo = TransferAuto()\n    if not isinstance(fill_value, Mapping):\n        fill_value = {key: fill_value for key in data}\n    prepared: TransferAlgorithmPrepared = algo.prepare(source, target)\n    source: pv.PointSet = melon.as_point_set(source)\n    result: Attrs = {}\n    for key in data:\n        attr: np.ndarray = source.point_data[key]\n        fill: ScalarLike = get_fill_value(attr.dtype, fill_value.get(key))\n        result[key] = prepared.transfer(attr, fill_value=fill)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/#liblaf.melon.ops.transform","title":"transform","text":"<pre><code>transform(\n    data: Any,\n    trans: Float[ArrayLike, \"4 4\"] | None,\n    *,\n    transform_all_input_vectors: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_transform.py</code> <pre><code>def transform(\n    data: Any,\n    trans: Float[ArrayLike, \"4 4\"] | None,\n    *,\n    transform_all_input_vectors: bool = False,\n) -&gt; pv.PolyData:\n    if trans is None:\n        return data\n    trans: Float[np.ndarray, \"4 4\"] = np.asarray(trans)\n    data: pv.PolyData = melon.as_poly_data(data)\n    data = data.transform(\n        trans, transform_all_input_vectors=transform_all_input_vectors, inplace=False\n    )  # pyright: ignore[reportAssignmentType]\n    return data\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/","title":"liblaf.melon.ops.correspondence","text":"<p>Classes:</p> <ul> <li> <code>InvalidNormalThresholdError</code>           \u2013            </li> <li> <code>NearestPointOnSurface</code>           \u2013            </li> <li> <code>NearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>NearestPointOnSurfaceResult</code>           \u2013            </li> <li> <code>NearestVertex</code>           \u2013            </li> <li> <code>NearestVertexPrepared</code>           \u2013            </li> <li> <code>NearestVertexResult</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>nearest_point_on_surface</code>             \u2013              </li> <li> <code>nearest_vertex</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.InvalidNormalThresholdError","title":"InvalidNormalThresholdError","text":"<pre><code>InvalidNormalThresholdError(normal_threshold: float)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>Attributes:</p> <ul> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/ops/correspondence/_errors.py</code> <pre><code>def __init__(self, normal_threshold: float) -&gt; None:\n    self.normal_threshold = normal_threshold\n    msg: str = f\"Invalid normal threshold: {normal_threshold}\\n\"\n    msg += \"Normal threshold must be in the range [-1.0, 1.0]\"\n    super().__init__(msg)\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.InvalidNormalThresholdError.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = normal_threshold\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface","title":"NearestPointOnSurface","text":"<p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def prepare(self, source: Any) -&gt; NearestPointOnSurfacePrepared:\n    source: tm.Trimesh = melon.as_trimesh(source)\n    return NearestPointOnSurfacePrepared(\n        distance_threshold=self.distance_threshold,\n        fallback_to_nearest_vertex=self.fallback_to_nearest_vertex,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared","title":"NearestPointOnSurfacePrepared","text":"<p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: Trimesh\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfacePrepared.query","title":"query","text":"<pre><code>query(target: Any) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def query(self, target: Any) -&gt; NearestPointOnSurfaceResult:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    target: pv.PointSet = melon.as_point_set(target, point_normals=need_normals)\n    nearest: Float[np.ndarray, \"N 3\"]\n    distance: Float[np.ndarray, \" N\"]\n    triangle_id: Integer[np.ndarray, \" N\"]\n    nearest, distance, triangle_id = self.source.nearest.on_surface(target.points)\n    missing: Bool[np.ndarray, \" N\"] = (\n        distance &gt; self.distance_threshold * self.source.scale\n    )\n    if need_normals:\n        source_normals: Float[np.ndarray, \"N 3\"] = self.source.face_normals[\n            triangle_id\n        ]\n        target_normals: Float[np.ndarray, \"N 3\"] = target.point_data[\"Normals\"]\n        normal_similarity: Float[np.ndarray, \" N\"] = np.vecdot(\n            source_normals, target_normals\n        )\n        missing |= normal_similarity &lt; self.normal_threshold\n    distance[missing] = np.inf\n    nearest[missing] = np.nan\n    triangle_id[missing] = -1\n    result = NearestPointOnSurfaceResult(\n        distance=distance, missing=missing, nearest=nearest, triangle_id=triangle_id\n    )\n    if self.fallback_to_nearest_vertex:\n        result = self._fallback_to_nearest_vertex(target, result)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfaceResult","title":"NearestPointOnSurfaceResult","text":"<p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' N']</code>)           \u2013            <p>(N,) float</p> </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' N']</code>)           \u2013            <p>(N,) bool</p> </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'N 3']</code>)           \u2013            <p>(N, 3) float</p> </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            <p>(N,) int</p> </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfaceResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' N']\n</code></pre> <p>(N,) float</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfaceResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' N']\n</code></pre> <p>(N,) bool</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfaceResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'N 3']\n</code></pre> <p>(N, 3) float</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestPointOnSurfaceResult.triangle_id","title":"triangle_id  <code>instance-attribute</code>","text":"<pre><code>triangle_id: Integer[ndarray, ' N']\n</code></pre> <p>(N,) int</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertex","title":"NearestVertex","text":"<p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertex.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertex.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertex.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertex.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertex.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestVertexPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def prepare(self, source: Any) -&gt; NearestVertexPrepared:\n    source: pv.PointSet = melon.as_point_set(\n        source, point_normals=self.normal_threshold &gt; -1.0\n    )\n    tree = KDTree(source.points)\n    return NearestVertexPrepared(\n        distance_threshold=self.distance_threshold,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n        tree=tree,\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared","title":"NearestVertexPrepared","text":"<p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: PointSet\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.tree","title":"tree  <code>instance-attribute</code>","text":"<pre><code>tree: KDTree\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexPrepared.query","title":"query","text":"<pre><code>query(target: Any) -&gt; NearestVertexResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def query(self, target: Any) -&gt; NearestVertexResult:\n    if self.normal_threshold &lt;= -1.0:\n        return self._nearest_vertex(target)\n    return self._nearest_vertex_with_normal_threshold(target)\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexResult","title":"NearestVertexResult","text":"<p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' N']</code>)           \u2013            <p>(N,) float</p> </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' N']</code>)           \u2013            <p>(N,) bool</p> </li> <li> <code>nearest</code>               (<code>Float[ndarray, ' N 3']</code>)           \u2013            <p>(N, 3) float</p> </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            <p>(N,) int</p> </li> </ul>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' N']\n</code></pre> <p>(N,) float</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' N']\n</code></pre> <p>(N,) bool</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, ' N 3']\n</code></pre> <p>(N, 3) float</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.NearestVertexResult.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' N']\n</code></pre> <p>(N,) int</p>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.nearest_point_on_surface","title":"nearest_point_on_surface","text":"<pre><code>nearest_point_on_surface(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    fallback_to_nearest_vertex: bool = False,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_point_on_surface.py</code> <pre><code>def nearest_point_on_surface(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    fallback_to_nearest_vertex: bool = False,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestPointOnSurfaceResult:\n    algorithm = NearestPointOnSurface(\n        distance_threshold=distance_threshold,\n        fallback_to_nearest_vertex=fallback_to_nearest_vertex,\n        max_k=max_k,\n        normal_threshold=normal_threshold,\n        workers=workers,\n    )\n    prepared: NearestPointOnSurfacePrepared = algorithm.prepare(source)\n    return prepared.query(target)\n</code></pre>"},{"location":"api/liblaf/melon/ops/correspondence/#liblaf.melon.ops.correspondence.nearest_vertex","title":"nearest_vertex","text":"<pre><code>nearest_vertex(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestVertexResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/correspondence/_nearest_vertex.py</code> <pre><code>def nearest_vertex(\n    source: Any,\n    target: Any,\n    *,\n    distance_threshold: float = 0.1,\n    max_k: int = 32,\n    normal_threshold: float = 0.8,\n    workers: int = -1,\n) -&gt; NearestVertexResult:\n    algorithm = NearestVertex(\n        distance_threshold=distance_threshold,\n        max_k=max_k,\n        normal_threshold=normal_threshold,\n        workers=workers,\n    )\n    prepared: NearestVertexPrepared = algorithm.prepare(source)\n    return prepared.query(target)\n</code></pre>"},{"location":"api/liblaf/melon/ops/pyvista/","title":"liblaf.melon.ops.pyvista","text":"<p>Functions:</p> <ul> <li> <code>contour</code>             \u2013              </li> <li> <code>ensure_positive_volume</code>             \u2013              </li> <li> <code>extract_points</code>             \u2013              </li> <li> <code>gaussian_smooth</code>             \u2013              </li> <li> <code>transform</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/pyvista/#liblaf.melon.ops.pyvista.contour","title":"contour","text":"<pre><code>contour(\n    data: Any,\n    isosurfaces: int | Sequence[float] | None = None,\n    scalars: str | Float[ArrayLike, ...] | None = None,\n    *,\n    compute_normals: bool = False,\n    compute_gradients: bool = False,\n    compute_scalars: bool = True,\n    rng: Sequence[float] | None = None,\n    preference: Literal[\"point\", \"cell\"] = \"point\",\n    method: Literal[\n        \"contour\", \"marching_cubes\", \"flying_edges\"\n    ] = \"contour\",\n    progress_bar: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_contour.py</code> <pre><code>def contour(\n    data: Any,\n    isosurfaces: int | Sequence[float] | None = None,\n    scalars: str | Float[ArrayLike, \"...\"] | None = None,\n    *,\n    compute_normals: bool = False,\n    compute_gradients: bool = False,\n    compute_scalars: bool = True,\n    rng: Sequence[float] | None = None,\n    preference: Literal[\"point\", \"cell\"] = \"point\",\n    method: Literal[\"contour\", \"marching_cubes\", \"flying_edges\"] = \"contour\",\n    progress_bar: bool = False,\n) -&gt; pv.PolyData:\n    data: pv.ImageData = melon.as_image_data(data)\n    result: pv.PolyData = data.contour(  # pyright: ignore[reportAssignmentType]\n        isosurfaces=isosurfaces,  # pyright: ignore[reportArgumentType]\n        scalars=scalars,\n        compute_normals=compute_normals,\n        compute_gradients=compute_gradients,\n        compute_scalars=compute_scalars,\n        rng=rng,\n        preference=preference,\n        method=method,\n        progress_bar=progress_bar,\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/pyvista/#liblaf.melon.ops.pyvista.ensure_positive_volume","title":"ensure_positive_volume","text":"<pre><code>ensure_positive_volume(mesh: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_tetra.py</code> <pre><code>def ensure_positive_volume(mesh: Any) -&gt; pv.UnstructuredGrid:\n    mesh: pv.UnstructuredGrid = melon.as_unstructured_grid(mesh)\n    mesh = mesh.compute_cell_sizes(\n        length=False, area=False, volume=True, vertex_count=False\n    )  # pyright: ignore[reportAssignmentType]\n    return flip(mesh, mask=mesh.cell_data[\"Volume\"] &lt; 0)\n</code></pre>"},{"location":"api/liblaf/melon/ops/pyvista/#liblaf.melon.ops.pyvista.extract_points","title":"extract_points","text":"<pre><code>extract_points(\n    data: Any,\n    ind: Bool[ArrayLike, \" N\"] | Integer[ArrayLike, \" N\"],\n) -&gt; PointSet\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_extract_points.py</code> <pre><code>def extract_points(\n    data: Any, ind: Bool[ArrayLike, \" N\"] | Integer[ArrayLike, \" N\"]\n) -&gt; pv.PointSet:\n    data: pv.PointSet = melon.as_point_set(data)\n    unstructured: pv.UnstructuredGrid = data.extract_points(ind)  # pyright: ignore[reportAssignmentType]\n    return melon.as_point_set(unstructured)\n</code></pre>"},{"location":"api/liblaf/melon/ops/pyvista/#liblaf.melon.ops.pyvista.gaussian_smooth","title":"gaussian_smooth","text":"<pre><code>gaussian_smooth(\n    data: Any,\n    radius_factor: float | Sequence[float] = 1.5,\n    std_dev: float | Sequence[float] = 2.0,\n    scalars: str | None = None,\n    *,\n    progress_bar: bool = False,\n) -&gt; ImageData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_gaussian_smooth.py</code> <pre><code>def gaussian_smooth(\n    data: Any,\n    radius_factor: float | Sequence[float] = 1.5,\n    std_dev: float | Sequence[float] = 2.0,\n    scalars: str | None = None,\n    *,\n    progress_bar: bool = False,\n) -&gt; pv.ImageData:\n    data: pv.ImageData = melon.as_image_data(data)\n    result: pv.ImageData = data.gaussian_smooth(  # pyright: ignore[reportAssignmentType]\n        radius_factor=radius_factor,  # pyright: ignore[reportArgumentType]\n        std_dev=std_dev,  # pyright: ignore[reportArgumentType]\n        scalars=scalars,\n        progress_bar=progress_bar,\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/pyvista/#liblaf.melon.ops.pyvista.transform","title":"transform","text":"<pre><code>transform(\n    data: Any,\n    trans: Float[ArrayLike, \"4 4\"] | None,\n    *,\n    transform_all_input_vectors: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/ops/pyvista/_transform.py</code> <pre><code>def transform(\n    data: Any,\n    trans: Float[ArrayLike, \"4 4\"] | None,\n    *,\n    transform_all_input_vectors: bool = False,\n) -&gt; pv.PolyData:\n    if trans is None:\n        return data\n    trans: Float[np.ndarray, \"4 4\"] = np.asarray(trans)\n    data: pv.PolyData = melon.as_poly_data(data)\n    data = data.transform(\n        trans, transform_all_input_vectors=transform_all_input_vectors, inplace=False\n    )  # pyright: ignore[reportAssignmentType]\n    return data\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/","title":"liblaf.melon.ops.registration","text":"<p>Modules:</p> <ul> <li> <code>rigid</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>RigidICP</code>           \u2013            </li> <li> <code>RigidRegistrationAlgorithm</code>           \u2013            </li> <li> <code>RigidRegistrationResult</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>rigid_align</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP","title":"RigidICP","text":"<p>               Bases: <code>RigidRegistrationAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>corresp_algo</code>               (<code>NearestVertex</code>)           \u2013            </li> <li> <code>loss_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_iters</code>               (<code>int</code>)           \u2013            </li> <li> <code>reflection</code>               (<code>bool</code>)           \u2013            </li> <li> <code>scale</code>               (<code>bool</code>)           \u2013            </li> <li> <code>translation</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.corresp_algo","title":"corresp_algo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>corresp_algo: NearestVertex = field(factory=NearestVertex)\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.loss_threshold","title":"loss_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loss_threshold: float = 1e-06\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.max_iters","title":"max_iters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_iters: int = 100\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scale: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.translation","title":"translation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>translation: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidICP.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_icp.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult:\n    corresp_algo_prepared: melon.NearestVertexPrepared = self.corresp_algo.prepare(\n        target\n    )\n    source: pv.PolyData = melon.as_poly_data(source)\n    target: pv.PolyData = melon.as_poly_data(target)\n    init_transform: Float[np.ndarray, \"4 4\"] = np.asarray(init_transform)\n    result = RigidRegistrationResult(\n        init_transform=init_transform,\n        loss=np.nan,\n        transformation=init_transform,\n        history=[np.eye(4)],\n    )\n    source_weights: Float[np.ndarray, \" N\"] | None = source.point_data.get(\n        \"Weights\"\n    )\n    target_weights: Float[np.ndarray, \" N\"] | None = target.point_data.get(\n        \"Weights\"\n    )\n    for it in range(self.max_iters):\n        transformed: pv.PolyData = source.transform(\n            result.transformation, inplace=False\n        )  # pyright: ignore[reportAssignmentType]\n        corresp: melon.NearestVertexResult = corresp_algo_prepared.query(\n            transformed\n        )\n        valid_mask: Bool[np.ndarray, \" N\"] = ~corresp.missing\n        matrix: Float[np.ndarray, \"4 4\"]\n        cost: float\n        source_points: Float[np.ndarray, \"N 3\"] = transformed.points[valid_mask]\n        target_points: Float[np.ndarray, \"N 3\"] = corresp.nearest[valid_mask]\n        weights: Float[np.ndarray, \" N\"] = np.ones((source_points.shape[0],))\n        if source_weights:\n            weights *= source_weights[valid_mask]\n        if target_weights:\n            weights *= target_weights[corresp.vertex_id[valid_mask]]\n        matrix, _, cost = tm.registration.procrustes(\n            source_points,\n            target_points,\n            weights=weights,\n            reflection=self.reflection,\n            translation=self.translation,\n            scale=self.scale,\n            return_cost=True,\n        )\n        last_loss: float = result.loss\n        result.loss = cost\n        result.transformation = matrix @ result.transformation\n        result.history.append(result.transformation)\n        # log loss metric\n        logger.debug(\"ICP (it: {}) &gt; loss: {}\", it, cost)\n        if last_loss - cost &lt; self.loss_threshold:\n            break\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationAlgorithm","title":"RigidRegistrationAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationAlgorithm.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_abc.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationResult","title":"RigidRegistrationResult","text":"<p>Attributes:</p> <ul> <li> <code>history</code>               (<code>list[Float[ndarray, '4 4']]</code>)           \u2013            </li> <li> <code>init_transform</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> <li> <code>loss</code>               (<code>float</code>)           \u2013            </li> <li> <code>transformation</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationResult.history","title":"history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history: list[Float[ndarray, '4 4']] = field(factory=list)\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationResult.init_transform","title":"init_transform  <code>instance-attribute</code>","text":"<pre><code>init_transform: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationResult.loss","title":"loss  <code>instance-attribute</code>","text":"<pre><code>loss: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.RigidRegistrationResult.transformation","title":"transformation  <code>instance-attribute</code>","text":"<pre><code>transformation: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/#liblaf.melon.ops.registration.rigid_align","title":"rigid_align","text":"<pre><code>rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_main.py</code> <pre><code>def rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult:\n    algorithm = algorithm or RigidICP()\n    init_transform = np.eye(4) if init_transform is None else init_transform\n    result: RigidRegistrationResult = algorithm.register(\n        source, target, init_transform=init_transform\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/","title":"liblaf.melon.ops.registration.rigid","text":"<p>Classes:</p> <ul> <li> <code>RigidICP</code>           \u2013            </li> <li> <code>RigidRegistrationAlgorithm</code>           \u2013            </li> <li> <code>RigidRegistrationResult</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>rigid_align</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP","title":"RigidICP","text":"<p>               Bases: <code>RigidRegistrationAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>corresp_algo</code>               (<code>NearestVertex</code>)           \u2013            </li> <li> <code>loss_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_iters</code>               (<code>int</code>)           \u2013            </li> <li> <code>reflection</code>               (<code>bool</code>)           \u2013            </li> <li> <code>scale</code>               (<code>bool</code>)           \u2013            </li> <li> <code>translation</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.corresp_algo","title":"corresp_algo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>corresp_algo: NearestVertex = field(factory=NearestVertex)\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.loss_threshold","title":"loss_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loss_threshold: float = 1e-06\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.max_iters","title":"max_iters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_iters: int = 100\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.reflection","title":"reflection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reflection: bool = False\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scale: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.translation","title":"translation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>translation: bool = True\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidICP.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_icp.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult:\n    corresp_algo_prepared: melon.NearestVertexPrepared = self.corresp_algo.prepare(\n        target\n    )\n    source: pv.PolyData = melon.as_poly_data(source)\n    target: pv.PolyData = melon.as_poly_data(target)\n    init_transform: Float[np.ndarray, \"4 4\"] = np.asarray(init_transform)\n    result = RigidRegistrationResult(\n        init_transform=init_transform,\n        loss=np.nan,\n        transformation=init_transform,\n        history=[np.eye(4)],\n    )\n    source_weights: Float[np.ndarray, \" N\"] | None = source.point_data.get(\n        \"Weights\"\n    )\n    target_weights: Float[np.ndarray, \" N\"] | None = target.point_data.get(\n        \"Weights\"\n    )\n    for it in range(self.max_iters):\n        transformed: pv.PolyData = source.transform(\n            result.transformation, inplace=False\n        )  # pyright: ignore[reportAssignmentType]\n        corresp: melon.NearestVertexResult = corresp_algo_prepared.query(\n            transformed\n        )\n        valid_mask: Bool[np.ndarray, \" N\"] = ~corresp.missing\n        matrix: Float[np.ndarray, \"4 4\"]\n        cost: float\n        source_points: Float[np.ndarray, \"N 3\"] = transformed.points[valid_mask]\n        target_points: Float[np.ndarray, \"N 3\"] = corresp.nearest[valid_mask]\n        weights: Float[np.ndarray, \" N\"] = np.ones((source_points.shape[0],))\n        if source_weights:\n            weights *= source_weights[valid_mask]\n        if target_weights:\n            weights *= target_weights[corresp.vertex_id[valid_mask]]\n        matrix, _, cost = tm.registration.procrustes(\n            source_points,\n            target_points,\n            weights=weights,\n            reflection=self.reflection,\n            translation=self.translation,\n            scale=self.scale,\n            return_cost=True,\n        )\n        last_loss: float = result.loss\n        result.loss = cost\n        result.transformation = matrix @ result.transformation\n        result.history.append(result.transformation)\n        # log loss metric\n        logger.debug(\"ICP (it: {}) &gt; loss: {}\", it, cost)\n        if last_loss - cost &lt; self.loss_threshold:\n            break\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationAlgorithm","title":"RigidRegistrationAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationAlgorithm.register","title":"register","text":"<pre><code>register(\n    source: Any,\n    target: Any,\n    *,\n    init_transform: Float[ArrayLike, \"4 4\"],\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_abc.py</code> <pre><code>def register(\n    self, source: Any, target: Any, *, init_transform: Float[ArrayLike, \"4 4\"]\n) -&gt; RigidRegistrationResult: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationResult","title":"RigidRegistrationResult","text":"<p>Attributes:</p> <ul> <li> <code>history</code>               (<code>list[Float[ndarray, '4 4']]</code>)           \u2013            </li> <li> <code>init_transform</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> <li> <code>loss</code>               (<code>float</code>)           \u2013            </li> <li> <code>transformation</code>               (<code>Float[ndarray, '4 4']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationResult.history","title":"history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history: list[Float[ndarray, '4 4']] = field(factory=list)\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationResult.init_transform","title":"init_transform  <code>instance-attribute</code>","text":"<pre><code>init_transform: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationResult.loss","title":"loss  <code>instance-attribute</code>","text":"<pre><code>loss: float\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.RigidRegistrationResult.transformation","title":"transformation  <code>instance-attribute</code>","text":"<pre><code>transformation: Float[ndarray, '4 4']\n</code></pre>"},{"location":"api/liblaf/melon/ops/registration/rigid/#liblaf.melon.ops.registration.rigid.rigid_align","title":"rigid_align","text":"<pre><code>rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult\n</code></pre> Source code in <code>src/liblaf/melon/ops/registration/rigid/_main.py</code> <pre><code>def rigid_align(\n    source: Any,\n    target: Any,\n    *,\n    algorithm: RigidRegistrationAlgorithm | None = None,\n    init_transform: Float[ArrayLike, \"4 4\"] | None = None,\n) -&gt; RigidRegistrationResult:\n    algorithm = algorithm or RigidICP()\n    init_transform = np.eye(4) if init_transform is None else init_transform\n    result: RigidRegistrationResult = algorithm.register(\n        source, target, init_transform=init_transform\n    )\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/selection/","title":"liblaf.melon.ops.selection","text":""},{"location":"api/liblaf/melon/ops/transfer/","title":"liblaf.melon.ops.transfer","text":"<p>Classes:</p> <ul> <li> <code>TransferAlgorithm</code>           \u2013            </li> <li> <code>TransferAlgorithmPrepared</code>           \u2013            </li> <li> <code>TransferAuto</code>           \u2013            </li> <li> <code>TransferAutoPrepared</code>           \u2013            </li> <li> <code>TransferNearestPointOnSurface</code>           \u2013            </li> <li> <code>TransferNearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>TransferNearestVertex</code>           \u2013            </li> <li> <code>TransferNearestVertexPrepared</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>get_fill_value</code>             \u2013              </li> <li> <code>transfer_point_to_point</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAlgorithm","title":"TransferAlgorithm","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAlgorithm.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferAlgorithmPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_abc.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferAlgorithmPrepared: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAlgorithmPrepared","title":"TransferAlgorithmPrepared","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAlgorithmPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Shaped[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_abc.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Shaped[np.ndarray, \"target_points ...\"]: ...\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAuto","title":"TransferAuto","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>categorial</code>               (<code>TransferAlgorithm</code>)           \u2013            </li> <li> <code>floating</code>               (<code>TransferAlgorithm</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAuto.categorial","title":"categorial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>categorial: TransferAlgorithm = field(\n    factory=TransferNearestVertex\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAuto.floating","title":"floating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>floating: TransferAlgorithm = field(\n    factory=TransferNearestPointOnSurface\n)\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAuto.prepare","title":"prepare","text":"<pre><code>prepare(source: Any, target: Any) -&gt; TransferAutoPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_auto.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferAutoPrepared:\n    return TransferAutoPrepared(\n        floating=self.floating.prepare(source, target),\n        categorial=self.categorial.prepare(source, target),\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAutoPrepared","title":"TransferAutoPrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>categorial</code>               (<code>TransferAlgorithmPrepared</code>)           \u2013            </li> <li> <code>floating</code>               (<code>TransferAlgorithmPrepared</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAutoPrepared.categorial","title":"categorial  <code>instance-attribute</code>","text":"<pre><code>categorial: TransferAlgorithmPrepared\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAutoPrepared.floating","title":"floating  <code>instance-attribute</code>","text":"<pre><code>floating: TransferAlgorithmPrepared\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferAutoPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Shaped[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_auto.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Shaped[np.ndarray, \"target_points ...\"]:\n    data: Shaped[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    if np.isdtype(data.dtype, (\"bool\", \"integer\")):\n        return self.categorial.transfer(data, fill_value)\n    return self.floating.transfer(data, fill_value)\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurface","title":"TransferNearestPointOnSurface","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = 0.8\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferNearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_point_on_surface.py</code> <pre><code>def prepare(\n    self, source: Any, target: Any\n) -&gt; TransferNearestPointOnSurfacePrepared:\n    source: tm.Trimesh = melon.as_trimesh(source)\n    corresp: melon.NearestPointOnSurfaceResult = melon.nearest_point_on_surface(\n        source,\n        target,\n        distance_threshold=self.distance_threshold,\n        normal_threshold=self.normal_threshold,\n    )\n    triangles: Integer[np.ndarray, \"target_points 3\"] = source.faces[\n        corresp.triangle_id\n    ]\n    barycentric: Float[np.ndarray, \"target_points 3\"] = (\n        tm.triangles.points_to_barycentric(\n            source.vertices[triangles], corresp.nearest\n        )\n    )\n    barycentric[corresp.missing] = np.nan\n    triangles[corresp.missing] = -1\n    return TransferNearestPointOnSurfacePrepared(\n        barycentric=barycentric, missing=corresp.missing, triangles=triangles\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurfacePrepared","title":"TransferNearestPointOnSurfacePrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>barycentric</code>               (<code>Float[ndarray, 'target_points 3']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' target_points']</code>)           \u2013            </li> <li> <code>triangles</code>               (<code>Integer[ndarray, 'target_points 3']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurfacePrepared.barycentric","title":"barycentric  <code>instance-attribute</code>","text":"<pre><code>barycentric: Float[ndarray, 'target_points 3']\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurfacePrepared.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurfacePrepared.triangles","title":"triangles  <code>instance-attribute</code>","text":"<pre><code>triangles: Integer[ndarray, 'target_points 3']\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestPointOnSurfacePrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Float[ndarray, \"target_points ...\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_point_on_surface.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Float[np.ndarray, \"target_points ...\"]:\n    data: Float[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    result: Float[np.ndarray, \"target_points ...\"] = np.einsum(\n        \"ij,ij...-&gt;i...\", self.barycentric, data[self.triangles], dtype=data.dtype\n    )\n    result[self.missing] = fill_value\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertex","title":"TransferNearestVertex","text":"<p>               Bases: <code>TransferAlgorithm</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_upper_bound</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertex.distance_upper_bound","title":"distance_upper_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_upper_bound: float = 0.1\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertex.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertex.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = 0.8\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertex.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertex.prepare","title":"prepare","text":"<pre><code>prepare(\n    source: Any, target: Any\n) -&gt; TransferNearestVertexPrepared\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_vertex.py</code> <pre><code>def prepare(self, source: Any, target: Any) -&gt; TransferNearestVertexPrepared:\n    corresp: melon.NearestVertexResult = melon.nearest_vertex(\n        source,\n        target,\n        distance_threshold=self.distance_upper_bound,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n    )\n    return TransferNearestVertexPrepared(\n        missing=corresp.missing, vertex_id=corresp.vertex_id\n    )\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertexPrepared","title":"TransferNearestVertexPrepared","text":"<p>               Bases: <code>TransferAlgorithmPrepared</code></p> <p>Methods:</p> <ul> <li> <code>transfer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>missing</code>               (<code>Bool[ndarray, ' target_points']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' target_points']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertexPrepared.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertexPrepared.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' target_points']\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.TransferNearestVertexPrepared.transfer","title":"transfer","text":"<pre><code>transfer(\n    data: Shaped[ArrayLike, \"source_points ...\"],\n    fill_value: ScalarLike,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_nearest_vertex.py</code> <pre><code>def transfer(\n    self, data: Shaped[ArrayLike, \"source_points ...\"], fill_value: ScalarLike\n) -&gt; Any:\n    data: Num[np.ndarray, \"source_points ...\"] = np.asarray(data)\n    result: Shaped[np.ndarray, \"target_points ...\"] = data[self.vertex_id].copy()\n    result[self.missing] = fill_value\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.get_fill_value","title":"get_fill_value","text":"<pre><code>get_fill_value(\n    dtype: DTypeLike, fill_value: ScalarLike | None = None\n) -&gt; ScalarLike\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_utils.py</code> <pre><code>def get_fill_value(\n    dtype: DTypeLike, fill_value: ScalarLike | None = None\n) -&gt; ScalarLike:\n    if fill_value is not None:\n        return fill_value\n    return np.zeros((), dtype=dtype).item()\n</code></pre>"},{"location":"api/liblaf/melon/ops/transfer/#liblaf.melon.ops.transfer.transfer_point_to_point","title":"transfer_point_to_point","text":"<pre><code>transfer_point_to_point(\n    source: Any,\n    target: Any,\n    data: Iterable[str],\n    *,\n    algo: TransferAlgorithm | None = None,\n    fill_value: ScalarLike\n    | Mapping[str, ScalarLike | None]\n    | None = None,\n) -&gt; Attrs\n</code></pre> Source code in <code>src/liblaf/melon/ops/transfer/_transfer.py</code> <pre><code>def transfer_point_to_point(\n    source: Any,\n    target: Any,\n    data: Iterable[str],\n    *,\n    algo: TransferAlgorithm | None = None,\n    fill_value: ScalarLike | Mapping[str, ScalarLike | None] | None = None,\n) -&gt; Attrs:\n    if algo is None:\n        algo = TransferAuto()\n    if not isinstance(fill_value, Mapping):\n        fill_value = {key: fill_value for key in data}\n    prepared: TransferAlgorithmPrepared = algo.prepare(source, target)\n    source: pv.PointSet = melon.as_point_set(source)\n    result: Attrs = {}\n    for key in data:\n        attr: np.ndarray = source.point_data[key]\n        fill: ScalarLike = get_fill_value(attr.dtype, fill_value.get(key))\n        result[key] = prepared.transfer(attr, fill_value=fill)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/ops/transformations/","title":"liblaf.melon.ops.transformations","text":"<p>Functions:</p> <ul> <li> <code>concat_transforms</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/ops/transformations/#liblaf.melon.ops.transformations.concat_transforms","title":"concat_transforms","text":"<pre><code>concat_transforms(\n    *transform: Float[ArrayLike, \"4 4\"] | None,\n) -&gt; Float[ndarray, \"4 4\"]\n</code></pre> Source code in <code>src/liblaf/melon/ops/transformations/_concat.py</code> <pre><code>def concat_transforms(\n    *transform: Float[ArrayLike, \"4 4\"] | None,\n) -&gt; Float[np.ndarray, \"4 4\"]:\n    result: Float[np.ndarray, \"4 4\"] = np.eye(4)\n    for t in transform:\n        if t is None:\n            continue\n        result = result @ np.asarray(t)\n    return result\n</code></pre>"},{"location":"api/liblaf/melon/plugin/","title":"liblaf.melon.plugin","text":"<p>Modules:</p> <ul> <li> <code>wrap</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/plugin/wrap/","title":"liblaf.melon.plugin.wrap","text":"<p>Modules:</p> <ul> <li> <code>resources</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>fast_wrapping</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/plugin/wrap/#liblaf.melon.plugin.wrap.fast_wrapping","title":"fast_wrapping","text":"<pre><code>fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"N 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"N 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" N\"]\n    | None = None,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/plugin/wrap/_fast_wrapping.py</code> <pre><code>def fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"N 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"N 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" N\"] | None = None,\n) -&gt; pv.PolyData:\n    source_landmarks = source_landmarks if source_landmarks is not None else []\n    target_landmarks = target_landmarks if target_landmarks is not None else []\n    free_polygons_floating = (\n        free_polygons_floating if free_polygons_floating is not None else []\n    )\n    with tempfile.TemporaryDirectory() as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        source_path: Path = tmpdir / \"source.obj\"\n        target_path: Path = tmpdir / \"target.obj\"\n        output_path: Path = tmpdir / \"output.obj\"\n        source_landmarks_path: Path = tmpdir / \"source.landmarks.json\"\n        target_landmarks_path: Path = tmpdir / \"target.landmarks.json\"\n        free_polygons_floating_path: Path = tmpdir / \"free-polygons-floating.json\"\n        melon.save(source_path, source)\n        melon.save(target_path, target)\n        melon.save_landmarks(source_landmarks_path, source_landmarks)\n        melon.save_landmarks(target_landmarks_path, target_landmarks)\n        melon.save_polygons(free_polygons_floating_path, free_polygons_floating)\n        template = string.Template(\n            (\n                importlib.resources.files(\"liblaf.melon.plugin.wrap.resources\")\n                / \"fast-wrapping.wrap\"\n            ).read_text()\n        )\n        project: str = template.substitute(\n            {\n                \"BASEMESH\": str(source_path),\n                \"SCAN\": str(target_path),\n                \"OUTPUT\": str(output_path),\n                \"LEFT_LANDMARKS\": str(source_landmarks_path),\n                \"RIGHT_LANDMARKS\": str(target_landmarks_path),\n                \"FREE_POLYGONS_FLOATING\": str(free_polygons_floating_path),\n            }\n        )\n        project_path: Path = tmpdir / \"project.wrap\"\n        project_path.write_text(project)\n        sp.run([\"WrapCmd.sh\", \"compute\", project_path], check=True)\n        return melon.load_poly_data(output_path)\n</code></pre>"},{"location":"api/liblaf/melon/plugin/wrap/resources/","title":"liblaf.melon.plugin.wrap.resources","text":""},{"location":"api/liblaf/melon/struct/","title":"liblaf.melon.struct","text":"<p>Modules:</p> <ul> <li> <code>dicom</code>           \u2013            </li> <li> <code>dicom_dataset</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Acquisition</code>           \u2013            </li> <li> <code>AcquisitionMeta</code>           \u2013            </li> <li> <code>Attachments</code>           \u2013            </li> <li> <code>DICOM</code>           \u2013            </li> <li> <code>DICOMDataset</code>           \u2013            </li> <li> <code>DICOMDatasetMeta</code>           \u2013            </li> <li> <code>DICOMMeta</code>           \u2013            </li> <li> <code>Subject</code>           \u2013            </li> <li> <code>SubjectMeta</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>format_date</code>             \u2013              </li> <li> <code>parse_date</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition","title":"Acquisition","text":"<pre><code>Acquisition(\n    path: StrPath, meta: AcquisitionMeta | None = None\n)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisition_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>meta</code>               (<code>AcquisitionMeta</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_age</code>               (<code>int</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>subject_id</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def __init__(self, path: StrPath, meta: AcquisitionMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.acquisition_date","title":"acquisition_date  <code>property</code>","text":"<pre><code>acquisition_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: AcquisitionMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.patient_age","title":"patient_age  <code>property</code>","text":"<pre><code>patient_age: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.subject_id","title":"subject_id  <code>property</code>","text":"<pre><code>subject_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path, meta=self.meta)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Acquisition.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"acquisition.json\", self.meta)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta","title":"AcquisitionMeta","text":"<p>               Bases: <code>DICOMMeta</code></p> <p>Attributes:</p> <ul> <li> <code>AcquisitionDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientAge</code>               (<code>int</code>)           \u2013            </li> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta.AcquisitionDate","title":"AcquisitionDate  <code>instance-attribute</code>","text":"<pre><code>AcquisitionDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta.PatientAge","title":"PatientAge  <code>instance-attribute</code>","text":"<pre><code>PatientAge: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.AcquisitionMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments","title":"Attachments","text":"<pre><code>Attachments(path: StrPath)\n</code></pre> <p>Methods:</p> <ul> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    self.path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Attachments.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM","title":"DICOM","text":"<pre><code>DICOM(path: StrPath)\n</code></pre> <p>Methods:</p> <ul> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisition_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>dirfile</code>               (<code>FileDataset</code>)           \u2013            </li> <li> <code>dirfile_path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>first_record</code>               (<code>FileDataset</code>)           \u2013            </li> <li> <code>image_data</code>               (<code>ImageData</code>)           \u2013            </li> <li> <code>meta</code>               (<code>DICOMMeta</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_age</code>               (<code>int</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>record_filepaths</code>               (<code>list[Path]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom/_dicom.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    path = Path(path)\n    if path.name == \"DIRFILE\":\n        path = path.parent\n    self.path = path\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.acquisition_date","title":"acquisition_date  <code>property</code>","text":"<pre><code>acquisition_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.dirfile","title":"dirfile  <code>property</code>","text":"<pre><code>dirfile: FileDataset\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.dirfile_path","title":"dirfile_path  <code>property</code>","text":"<pre><code>dirfile_path: Path\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.first_record","title":"first_record  <code>property</code>","text":"<pre><code>first_record: FileDataset\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.image_data","title":"image_data  <code>property</code>","text":"<pre><code>image_data: ImageData\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: DICOMMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = path\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.patient_age","title":"patient_age  <code>property</code>","text":"<pre><code>patient_age: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.record_filepaths","title":"record_filepaths  <code>property</code>","text":"<pre><code>record_filepaths: list[Path]\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOM.save","title":"save","text":"<pre><code>save(path: StrPath) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_dicom.py</code> <pre><code>def save(self, path: StrPath) -&gt; None:\n    path = Path(path)\n    if path.name == \"DIRFILE\":\n        path = path.parent\n    path.mkdir(parents=True, exist_ok=True)\n    shutil.copy2(self.dirfile_path, path / \"DIRFILE\")\n    for record_filepath in self.record_filepaths:\n        shutil.copy2(record_filepath, path / record_filepath.name)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset","title":"DICOMDataset","text":"<pre><code>DICOMDataset(\n    path: StrPath, meta: DICOMDatasetMeta | None = None\n)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>add_subject</code>             \u2013              </li> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_acquisition</code>             \u2013              </li> <li> <code>get_subject</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisitions</code>               (<code>list[Acquisition]</code>)           \u2013            </li> <li> <code>meta</code>               (<code>DICOMDatasetMeta</code>)           \u2013            </li> <li> <code>n_acquisitions</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_subjects</code>               (<code>int</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>subjects</code>               (<code>list[Subject]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def __init__(self, path: StrPath, meta: DICOMDatasetMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.acquisitions","title":"acquisitions  <code>property</code>","text":"<pre><code>acquisitions: list[Acquisition]\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: DICOMDatasetMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.n_acquisitions","title":"n_acquisitions  <code>property</code>","text":"<pre><code>n_acquisitions: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.n_subjects","title":"n_subjects  <code>property</code>","text":"<pre><code>n_subjects: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.subjects","title":"subjects  <code>property</code>","text":"<pre><code>subjects: list[Subject]\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.add_subject","title":"add_subject","text":"<pre><code>add_subject(meta: SubjectMeta) -&gt; Subject\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def add_subject(self, meta: SubjectMeta) -&gt; Subject:\n    subject = Subject(self.path / meta.PatientID, meta)\n    self.meta.subjects.append(subject.id)\n    self.save_meta()\n    return subject\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.get_acquisition","title":"get_acquisition","text":"<pre><code>get_acquisition(\n    subject_id: str, acq_date: DateLike\n) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def get_acquisition(\n    self, subject_id: str, acq_date: melon.struct.dicom.DateLike\n) -&gt; Acquisition:\n    subject: Subject = self.get_subject(subject_id)\n    return subject.get_acquisition(acq_date)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.get_subject","title":"get_subject","text":"<pre><code>get_subject(subject_id: str) -&gt; Subject\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def get_subject(self, subject_id: str) -&gt; Subject:\n    return Subject(self.path / subject_id)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDataset.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"dataset.json\", self.meta)\n    for subject in self.subjects:\n        subject.save_meta(path / subject.id)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDatasetMeta","title":"DICOMDatasetMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>subjects</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMDatasetMeta.subjects","title":"subjects  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subjects: list[str] = []\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta","title":"DICOMMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>AcquisitionDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientAge</code>               (<code>int</code>)           \u2013            </li> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta.AcquisitionDate","title":"AcquisitionDate  <code>instance-attribute</code>","text":"<pre><code>AcquisitionDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta.PatientAge","title":"PatientAge  <code>instance-attribute</code>","text":"<pre><code>PatientAge: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.DICOMMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject","title":"Subject","text":"<pre><code>Subject(path: StrPath, meta: SubjectMeta | None = None)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>add_acquisition</code>             \u2013              </li> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_acquisition</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisitions</code>               (<code>list[Acquisition]</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>meta</code>               (<code>SubjectMeta</code>)           \u2013            </li> <li> <code>n_acquisitions</code>               (<code>int</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def __init__(self, path: StrPath, meta: SubjectMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.acquisitions","title":"acquisitions  <code>property</code>","text":"<pre><code>acquisitions: list[Acquisition]\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: SubjectMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.n_acquisitions","title":"n_acquisitions  <code>property</code>","text":"<pre><code>n_acquisitions: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(meta: AcquisitionMeta) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def add_acquisition(self, meta: AcquisitionMeta) -&gt; Acquisition:\n    acq_id: str = melon.struct.dicom.format_date(meta.AcquisitionDate)\n    acq = Acquisition(self.path / acq_id, meta)\n    self.meta.acquisitions.append(acq.acquisition_date)\n    self.save_meta()\n    return acq\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.get_acquisition","title":"get_acquisition","text":"<pre><code>get_acquisition(acq_date: DateLike) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def get_acquisition(self, acq_date: melon.struct.dicom.DateLike) -&gt; Acquisition:\n    acq_date: datetime.date = melon.struct.dicom.parse_date(acq_date)\n    return Acquisition(self.path / melon.struct.dicom.format_date(acq_date))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.Subject.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"subject.json\", self.meta)\n    for acq in self.acquisitions:\n        acq.save_meta(path / acq.id)\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.SubjectMeta","title":"SubjectMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>acquisitions</code>               (<code>list[Date]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.SubjectMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.SubjectMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.SubjectMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.SubjectMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.SubjectMeta.acquisitions","title":"acquisitions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisitions: list[Date] = []\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.format_date","title":"format_date","text":"<pre><code>format_date(date: date) -&gt; str\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>def format_date(date: datetime.date) -&gt; str:\n    return date.strftime(\"%Y%m%d\")\n</code></pre>"},{"location":"api/liblaf/melon/struct/#liblaf.melon.struct.parse_date","title":"parse_date","text":"<pre><code>parse_date(date: DateLike) -&gt; date\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>def parse_date(date: DateLike) -&gt; datetime.date:\n    match date:\n        case str():\n            return datetime.datetime.strptime(date, \"%Y%m%d\").date()  # noqa: DTZ007\n        case datetime.datetime():\n            return date.date()\n        case datetime.date():\n            return date\n        case _:\n            msg: str = f\"Invalid date: `{date}`\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/","title":"liblaf.melon.struct.dicom","text":"<p>Classes:</p> <ul> <li> <code>DICOM</code>           \u2013            </li> <li> <code>DICOMMeta</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>dcmread_cached</code>             \u2013              </li> <li> <code>format_date</code>             \u2013              </li> <li> <code>parse_date</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM","title":"DICOM","text":"<pre><code>DICOM(path: StrPath)\n</code></pre> <p>Methods:</p> <ul> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisition_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>dirfile</code>               (<code>FileDataset</code>)           \u2013            </li> <li> <code>dirfile_path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>first_record</code>               (<code>FileDataset</code>)           \u2013            </li> <li> <code>image_data</code>               (<code>ImageData</code>)           \u2013            </li> <li> <code>meta</code>               (<code>DICOMMeta</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_age</code>               (<code>int</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>record_filepaths</code>               (<code>list[Path]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom/_dicom.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    path = Path(path)\n    if path.name == \"DIRFILE\":\n        path = path.parent\n    self.path = path\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.acquisition_date","title":"acquisition_date  <code>property</code>","text":"<pre><code>acquisition_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.dirfile","title":"dirfile  <code>property</code>","text":"<pre><code>dirfile: FileDataset\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.dirfile_path","title":"dirfile_path  <code>property</code>","text":"<pre><code>dirfile_path: Path\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.first_record","title":"first_record  <code>property</code>","text":"<pre><code>first_record: FileDataset\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.image_data","title":"image_data  <code>property</code>","text":"<pre><code>image_data: ImageData\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: DICOMMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = path\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.patient_age","title":"patient_age  <code>property</code>","text":"<pre><code>patient_age: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.record_filepaths","title":"record_filepaths  <code>property</code>","text":"<pre><code>record_filepaths: list[Path]\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOM.save","title":"save","text":"<pre><code>save(path: StrPath) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_dicom.py</code> <pre><code>def save(self, path: StrPath) -&gt; None:\n    path = Path(path)\n    if path.name == \"DIRFILE\":\n        path = path.parent\n    path.mkdir(parents=True, exist_ok=True)\n    shutil.copy2(self.dirfile_path, path / \"DIRFILE\")\n    for record_filepath in self.record_filepaths:\n        shutil.copy2(record_filepath, path / record_filepath.name)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta","title":"DICOMMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>AcquisitionDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientAge</code>               (<code>int</code>)           \u2013            </li> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta.AcquisitionDate","title":"AcquisitionDate  <code>instance-attribute</code>","text":"<pre><code>AcquisitionDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta.PatientAge","title":"PatientAge  <code>instance-attribute</code>","text":"<pre><code>PatientAge: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.DICOMMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.dcmread_cached","title":"dcmread_cached  <code>cached</code>","text":"<pre><code>dcmread_cached(path: StrPath) -&gt; FileDataset\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>@functools.lru_cache\ndef dcmread_cached(path: StrPath) -&gt; pydicom.FileDataset:\n    return pydicom.dcmread(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.format_date","title":"format_date","text":"<pre><code>format_date(date: date) -&gt; str\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>def format_date(date: datetime.date) -&gt; str:\n    return date.strftime(\"%Y%m%d\")\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom/#liblaf.melon.struct.dicom.parse_date","title":"parse_date","text":"<pre><code>parse_date(date: DateLike) -&gt; date\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom/_utils.py</code> <pre><code>def parse_date(date: DateLike) -&gt; datetime.date:\n    match date:\n        case str():\n            return datetime.datetime.strptime(date, \"%Y%m%d\").date()  # noqa: DTZ007\n        case datetime.datetime():\n            return date.date()\n        case datetime.date():\n            return date\n        case _:\n            msg: str = f\"Invalid date: `{date}`\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/","title":"liblaf.melon.struct.dicom_dataset","text":"<p>Classes:</p> <ul> <li> <code>Acquisition</code>           \u2013            </li> <li> <code>AcquisitionMeta</code>           \u2013            </li> <li> <code>Attachments</code>           \u2013            </li> <li> <code>DICOMDataset</code>           \u2013            </li> <li> <code>DICOMDatasetMeta</code>           \u2013            </li> <li> <code>Subject</code>           \u2013            </li> <li> <code>SubjectMeta</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition","title":"Acquisition","text":"<pre><code>Acquisition(\n    path: StrPath, meta: AcquisitionMeta | None = None\n)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisition_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>meta</code>               (<code>AcquisitionMeta</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_age</code>               (<code>int</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>subject_id</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def __init__(self, path: StrPath, meta: AcquisitionMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.acquisition_date","title":"acquisition_date  <code>property</code>","text":"<pre><code>acquisition_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: AcquisitionMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.patient_age","title":"patient_age  <code>property</code>","text":"<pre><code>patient_age: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.subject_id","title":"subject_id  <code>property</code>","text":"<pre><code>subject_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path, meta=self.meta)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Acquisition.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_acquisition.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"acquisition.json\", self.meta)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta","title":"AcquisitionMeta","text":"<p>               Bases: <code>DICOMMeta</code></p> <p>Attributes:</p> <ul> <li> <code>AcquisitionDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientAge</code>               (<code>int</code>)           \u2013            </li> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta.AcquisitionDate","title":"AcquisitionDate  <code>instance-attribute</code>","text":"<pre><code>AcquisitionDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta.PatientAge","title":"PatientAge  <code>instance-attribute</code>","text":"<pre><code>PatientAge: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.AcquisitionMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments","title":"Attachments","text":"<pre><code>Attachments(path: StrPath)\n</code></pre> <p>Methods:</p> <ul> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def __init__(self, path: StrPath) -&gt; None:\n    self.path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Attachments.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset","title":"DICOMDataset","text":"<pre><code>DICOMDataset(\n    path: StrPath, meta: DICOMDatasetMeta | None = None\n)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>add_subject</code>             \u2013              </li> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_acquisition</code>             \u2013              </li> <li> <code>get_subject</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisitions</code>               (<code>list[Acquisition]</code>)           \u2013            </li> <li> <code>meta</code>               (<code>DICOMDatasetMeta</code>)           \u2013            </li> <li> <code>n_acquisitions</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_subjects</code>               (<code>int</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>subjects</code>               (<code>list[Subject]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def __init__(self, path: StrPath, meta: DICOMDatasetMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.acquisitions","title":"acquisitions  <code>property</code>","text":"<pre><code>acquisitions: list[Acquisition]\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: DICOMDatasetMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.n_acquisitions","title":"n_acquisitions  <code>property</code>","text":"<pre><code>n_acquisitions: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.n_subjects","title":"n_subjects  <code>property</code>","text":"<pre><code>n_subjects: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.subjects","title":"subjects  <code>property</code>","text":"<pre><code>subjects: list[Subject]\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.add_subject","title":"add_subject","text":"<pre><code>add_subject(meta: SubjectMeta) -&gt; Subject\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def add_subject(self, meta: SubjectMeta) -&gt; Subject:\n    subject = Subject(self.path / meta.PatientID, meta)\n    self.meta.subjects.append(subject.id)\n    self.save_meta()\n    return subject\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.get_acquisition","title":"get_acquisition","text":"<pre><code>get_acquisition(\n    subject_id: str, acq_date: DateLike\n) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def get_acquisition(\n    self, subject_id: str, acq_date: melon.struct.dicom.DateLike\n) -&gt; Acquisition:\n    subject: Subject = self.get_subject(subject_id)\n    return subject.get_acquisition(acq_date)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.get_subject","title":"get_subject","text":"<pre><code>get_subject(subject_id: str) -&gt; Subject\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def get_subject(self, subject_id: str) -&gt; Subject:\n    return Subject(self.path / subject_id)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDataset.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_dataset.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"dataset.json\", self.meta)\n    for subject in self.subjects:\n        subject.save_meta(path / subject.id)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDatasetMeta","title":"DICOMDatasetMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>subjects</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.DICOMDatasetMeta.subjects","title":"subjects  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subjects: list[str] = []\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject","title":"Subject","text":"<pre><code>Subject(path: StrPath, meta: SubjectMeta | None = None)\n</code></pre> <p>               Bases: <code>Attachments</code></p> <p>Methods:</p> <ul> <li> <code>add_acquisition</code>             \u2013              </li> <li> <code>clone</code>             \u2013              </li> <li> <code>from_data</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_acquisition</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>load_dicom</code>             \u2013              </li> <li> <code>load_poly_data</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>save_meta</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>acquisitions</code>               (<code>list[Acquisition]</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>meta</code>               (<code>SubjectMeta</code>)           \u2013            </li> <li> <code>n_acquisitions</code>               (<code>int</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>patient_birth_date</code>               (<code>date</code>)           \u2013            </li> <li> <code>patient_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>patient_sex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def __init__(self, path: StrPath, meta: SubjectMeta | None = None) -&gt; None:\n    super().__init__(path)\n    if meta is not None:\n        self.meta = meta\n        self.save_meta()\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.acquisitions","title":"acquisitions  <code>property</code>","text":"<pre><code>acquisitions: list[Acquisition]\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.meta","title":"meta  <code>cached</code> <code>property</code>","text":"<pre><code>meta: SubjectMeta\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.n_acquisitions","title":"n_acquisitions  <code>property</code>","text":"<pre><code>n_acquisitions: int\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path = Path(path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.patient_birth_date","title":"patient_birth_date  <code>property</code>","text":"<pre><code>patient_birth_date: date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.patient_id","title":"patient_id  <code>property</code>","text":"<pre><code>patient_id: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.patient_name","title":"patient_name  <code>property</code>","text":"<pre><code>patient_name: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.patient_sex","title":"patient_sex  <code>property</code>","text":"<pre><code>patient_sex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(meta: AcquisitionMeta) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def add_acquisition(self, meta: AcquisitionMeta) -&gt; Acquisition:\n    acq_id: str = melon.struct.dicom.format_date(meta.AcquisitionDate)\n    acq = Acquisition(self.path / acq_id, meta)\n    self.meta.acquisitions.append(acq.acquisition_date)\n    self.save_meta()\n    return acq\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.clone","title":"clone","text":"<pre><code>clone(path: StrPath) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def clone(self, path: StrPath) -&gt; Self:\n    self.save_meta(path)\n    return type(self)(path=path)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(path: StrPath, data: Mapping[str, Any]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>@classmethod\ndef from_data(cls, path: StrPath, data: Mapping[str, Any]) -&gt; Self:\n    self: Self = cls(path)\n    for key, value in data.items():\n        self.save(key, value)\n    return self\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    return self.path / key\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.get_acquisition","title":"get_acquisition","text":"<pre><code>get_acquisition(acq_date: DateLike) -&gt; Acquisition\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def get_acquisition(self, acq_date: melon.struct.dicom.DateLike) -&gt; Acquisition:\n    acq_date: datetime.date = melon.struct.dicom.parse_date(acq_date)\n    return Acquisition(self.path / melon.struct.dicom.format_date(acq_date))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.load","title":"load","text":"<pre><code>load(key: str) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    return melon.load(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.load_dicom","title":"load_dicom","text":"<pre><code>load_dicom(key: str) -&gt; DICOM\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_dicom(self, key: str) -&gt; melon.DICOM:\n    return melon.load_dicom(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.load_poly_data","title":"load_poly_data","text":"<pre><code>load_poly_data(key: str) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def load_poly_data(self, key: str) -&gt; pv.PolyData:\n    return melon.load_poly_data(self.get(key))\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.save","title":"save","text":"<pre><code>save(key: str, data: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_attachments.py</code> <pre><code>def save(self, key: str, data: Any) -&gt; None:\n    melon.save(self.get(key), data)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.Subject.save_meta","title":"save_meta","text":"<pre><code>save_meta(path: StrPath | None = None) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/struct/dicom_dataset/_subject.py</code> <pre><code>def save_meta(self, path: StrPath | None = None) -&gt; None:\n    path = Path(path) if path else self.path\n    path.mkdir(parents=True, exist_ok=True)\n    grapes.save_pydantic(path / \"subject.json\", self.meta)\n    for acq in self.acquisitions:\n        acq.save_meta(path / acq.id)\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.SubjectMeta","title":"SubjectMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>PatientBirthDate</code>               (<code>Date</code>)           \u2013            </li> <li> <code>PatientID</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientName</code>               (<code>str</code>)           \u2013            </li> <li> <code>PatientSex</code>               (<code>Literal['F', 'M']</code>)           \u2013            </li> <li> <code>acquisitions</code>               (<code>list[Date]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.SubjectMeta.PatientBirthDate","title":"PatientBirthDate  <code>instance-attribute</code>","text":"<pre><code>PatientBirthDate: Date\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.SubjectMeta.PatientID","title":"PatientID  <code>instance-attribute</code>","text":"<pre><code>PatientID: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.SubjectMeta.PatientName","title":"PatientName  <code>instance-attribute</code>","text":"<pre><code>PatientName: str\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.SubjectMeta.PatientSex","title":"PatientSex  <code>instance-attribute</code>","text":"<pre><code>PatientSex: Literal['F', 'M']\n</code></pre>"},{"location":"api/liblaf/melon/struct/dicom_dataset/#liblaf.melon.struct.dicom_dataset.SubjectMeta.acquisitions","title":"acquisitions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisitions: list[Date] = []\n</code></pre>"},{"location":"api/liblaf/melon/typed/","title":"liblaf.melon.typed","text":""}]}